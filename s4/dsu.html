<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>Деревья и графы. Система непересекающихся множеств. Поиск наименьшего общего предка.</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
    <script type="text/javascript" src="../syntax/sh_main.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_cpp.min.js"></script>
    <link type="text/css" rel="stylesheet" href="../style/sh_nedit.css">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>
<body onLoad="sh_highlightDocument();">
<div style="width:80%;">
    <div style="float:right;">
        <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
                codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0"
                width="100" height="50">
            <param name="movie" value="../audio/a_smsqulh3n.swf">
            <param name="bgcolor" value="fff">
            <param name="FlashVars" value="src=9094e666f613f513f50301------------ffffff">
            <param name="autoplay" value="false">
            <embed src="../audio/a_smsqulh3n.swf" bgcolor="fff"
                   width="100" height="70" type="application/x-shockwave-flash"
                   pluginspage="http://www.macromedia.com/go/getflashplayer"
                   FlashVars="src=9094e666f613f513f50301------------ffffff"></embed>
        </object>
    </div>
</div>

<div id="content">

    <h1>Деревья и графы. Система непересекающихся множеств. Поиск наименьшего общего предка.</h1>

    <ul class="tags">
        <li><a href="#">Теория графов</a></li>
    </ul>

    <h2>Система непересекающихся множеств</h2>

    <p>Структура данных "система непересекающихся множеств" (на английском "disjoint-set-union", или просто "DSU").</p>

    <p>Эта структура данных предоставляет следующие возможности.
        Изначально имеется несколько элементов, каждый из которых находится в отдельном (своём собственном) множестве.
        За одну операцию можно объединить два каких-либо множества, а также можно запросить,
        в каком множестве сейчас находится указанный элемент.
        Также, в классическом варианте, вводится ещё одна операция — создание нового элемента, который помещается в
        отдельное множество.
    </p>

    <p>Таким образом, базовый интерфейс данной структуры данных состоит всего из трёх операций:</p>

    <ul>
        <li><b>make_set(x)</b> — добавляет новый элемент $x$, помещая его в новое множество, состоящее из одного него.
        </li>
        <li><b>union_sets(x,y)</b> — объединяет два указанных множества (множество, в котором находится элемент $x$, и
            множество, в котором находится элемент $y$).
        </li>
        <li><b>find_set(x)</b> - возвращает, в каком множестве находится указанный элемент $x$.
            На самом деле при этом возвращается один из элементов множества (называемый представителем или лидером (в
            англоязычной литературе "leader")).
            Этот представитель выбирается в каждом множестве самой структурой данных (и может меняться с течением
            времени, а именно, после вызовов <b>union_sets()</b>).
            Например, если вызов <b>find_set()</b> для каких-то двух элементов вернул одно и то же значение,
            то это означает, что эти элементы находятся в одном и том же множестве, а в противном случае — в разных
            множествах.
        </li>
    </ul>

    <p>Описываемая ниже структура данных позволяет делать каждую из этих операций почти за $O(1)$ в среднем
        (более подробно об асимптотике см. ниже после описания алгоритма).
    </p>

</div>
</body>

</html>