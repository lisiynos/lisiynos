\begin{section}[Обработка запросов, хранение и построение дерева отрезков]{Обработка запросов, хранение и построение дерева отрезков}

\begin{subsection}[Хранение]{Хранение}
Рассмотрим, как можно хранить дерево отрезков. Сначала рассмотрим, каким образом
можно хранить дерево отрезков в виде подвешенного бинарного дерева: каждому отрезку из описанных ранее
разбиений сопоставим отдельную вершину дерева. Вершина $u$ будет являться
родителем вершины $v$ тогда и только тогда, когда отрезок, соответствующий $u$~--- наименьший
из всех отрезков, которые покрывают отрезок, соответствующий $v$. Тогда корню дерева
будет соответствовать отрезок, покрывающий весь массив, а листьям дерева будут соответствовать
отрезки, покрывающие отдельные элементы массива. При этом т.к. длины всех отрезков~--- степени 
двойки, то у каждой вершины будет ровно два сына (если эта вершина не является листом).

Теперь покажем, как можно хранить дерево отрезков в массиве. В описанном выше бинарном подвешенном 
дереве для каждой вершины вычислим расстояние от нее до корня и назовем уровнем вершины. 
Для каждой вершины левым сыном будем считать того из сыновей, которому соответствует отрезок массива, 
расположенный левее. Пронумеруем вершины следующим образом: корень будет иметь номер $1$, его 
левый сын~--- номер $2$, правый сын~--- номер $3$ и т.д.: слева направо номеровать вершины по мере 
увеличения уровня. Теперь значение вершины с номером $i$ будем хранить в $i$-м элементе массива. 
Заметим тогда, что значение, соотвествующее левому сыну вершины с номером $i$, будет находиться 
в $2i$-м элементе массива, правому сыну~--- в $2i + 1$-м, предку~--- в $i / 2$-м.

Всего для хранения дерева отрезков потребуется $O(N)$ памяти: в описанном выше дереве будет
одна вершина с расстоянием $0$ до корня, две~--- с расстоянием $1$, $2^k$~--- с расстоянием
$k$ до корня. Т.к. высота дерева отрезков~--- $\log N$, то $k \le \log(N)$ и 
$1 + 2 + 4 + .. + 2^{\log(N)} = 2 * 2^{\log(N)} - 1 = 2 * N - 1$.

\end{subsection}

\begin{subsection}[Обработка запросов]{Обработка запросов}

Рассмотрим обработку запросов более подробно. Начнем с запроса $set(i, x)$. Заметим, 
что если для некторой вершины $v$ известно, что значения ее сыновей являются истинными,
то в силу аддитивности суммы по отрезку истинное значение в $v$ можно вычислить как их
сумму за $O(1)$. Тогда покажем, как реализовать запрос $set(i,x)$. Рассмотрим наименьший
отрезок, в котором находится $i$-й элемент. Этот отрезок будет являться листом дерева 
отрезков и ему будет соответствовать отрезок только из $i$-го элемента. Новым значением 
суммы на этом отрезке будет $x$. Теперь перейдем к предку $i/2$ текущей вершины. Значение в одном
из его сыновей не менялось и, соответственно, является верным, значение в другом сыне
было пересчитано на предыдущем шаге и тоже является истинным. Тогда можно пересчитать
значение в $i/2$ и перейти к ее предку. Действуя так, пока предок существует 
($v \ne 0$, $v$~--- номер текущей вершины), мы обновим все дерево. Т.к. каждый раз при переходе
к предку расстояние до корня уменьшается на единицу (а номер вершины делится на 2), то
таких переходов будет $O(\log N)$.

Рассмотрим теперь запрос $get(l,r)$. Для его реализации (и всего дерева отрезков) существует
два различных метода: <<сверху>> и <<снизу>>. Описанная выше реализация $set$ является 
реализацией <<снизу>>, хотя может применяться и в методе <<сверху>>.

При реализации запроса $get$ <<снизу>> поддерживаетя следующий инвариант: на $i$-м шаге
$l$ и $r$ указывают на крайние левую и правую вершины, находящиеся на уровне $\log {N} - i$, 
которым соответствуют отрезки, покрытые еще не обработанной частью исходного запроса.
Переход на уровень выше производится следующим образом: заметим, что если вершина $l$ является
левым сыном, то ее предок является самой левой вершиной свего уровня, отрезок которой еще
полностью не обработан, поэтому перейти на уровень выше можно непосредственно в вершину $l / 2$. 
Если же $l$~--- правый сын, то ее отрезок ее предка уже частично обработан либо не лежит в 
запросе, поэтому переходить в него нельзя, но требуется обновить ответ, прибавив к нему 
значение в $l$ и перейти в вершину $l + 1$, которая является левым сыном своего предка.
Аналогично для вершины $r$~--- если $r$ правый сын, то можно перейти в его предка, иначе~---
добавить в ответ значение в вершине $r$, перейти в $r - 1$, которая является правым сыном
своего предка, и перейти в предка $r - 1$. Действовать так нужно, пока обрабатываемый отрезок
не пуст, т.е. $l \le r$. При этом т.к. каждый раз происходит переход на уровень вверх,
а уровней всего $\log N$, то запрос будет обрабатываться за $O(\log N)$.

При реализации запроса $get(l,r)$ сверху необходимо хранить в вершине дополнительную 
информацию~--- границы отрезка, которы соответствует этой вершине. Обработка запроса 
в этом случае происходит следующим рекурсивным методом: если $v$~--- текущая вершина,
$v_l$ и $v_r$~--- границы отрезка, который ей соответствует, то тогда:
\begin{itemize}

\item Если $l \le v_l$ и $v_r \le r$, то к ответу нужно добавить значение в $v$.
\item Если $v_r \le l$ или $r \le v_l$, то отрезок вершины $v$ не лежит в запросе и
обрабатывать $v$ не нужно.
\item Если ни одно из перечисленного не верно, то результатом запроса для вершины $v$
является сумма запросов сыновей $v$~--- $2v$ и $2v + 1$.

\end{itemize}
Заметим, что при таком методе на каждом уровне может быть посещено не более четырех вершин,
что также дает оценку $O(\log N)$ на время работы. Аналогично можно обрабатывать запрос $set$.

\end{subsection}

\begin{subsection}[Построение]{Построение}

Наконец, покажем, как построить над массивом дерево отрезков. За $O(N \log N$ это можно
сделать следующим образом: построить дерево отрезков на массиве из нулей (тогда в каждой
вершине будет храниться 0) и для каждого элемент массива произвести $set(i, a[i])$, где $a[i]$~---
исходный массив.

Однако построить дерево отрезков можно быстрее~--- за $O(N)$, используя один линейный проход по нему.
Сначала заполним самый нижний уровень. В нем хранятся суммы на отрезках с $i$ по $i$, т.е. элементы
исходного массива. Заметим, что если $k$-й уровень заполнен, то можно заполнить $k - 1$, для каждого
его элемента посчитав значение в нем как сумму значений в сыновьях. Таким образом, если сначала
заполнить нижний уровень элементами массива, а затем пройти по всем уровням снизу вверх, действуя 
указанным методом, то значения всех вершин дерева отрезков будут посчитаны корректно за линейное 
время.                                     

\end{subsection}

\end{section}