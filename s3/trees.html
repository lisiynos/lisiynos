<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>Деревья в программировании</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
    <script type="text/javascript" src="../syntax/sh_main.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_pascal.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_basic.js"></script>
    <link type="text/css" rel="stylesheet" href="../style/sh_nedit.css">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>
<body onLoad="sh_highlightDocument();">
<div style="width:80%;">
    <div style="float:right;">
        <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
                codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0"
                width="100" height="50">
            <param name="movie" value="../audio/a_smsqulh3n.swf">
            <param name="bgcolor" value="fff">
            <param name="FlashVars" value="src=9094e666f613f513f50301------------ffffff">
            <param name="autoplay" value="false">
            <embed src="../audio/a_smsqulh3n.swf" bgcolor="fff" width="100" height="70"
                   type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer"
                   FlashVars="src=9094e666f613f513f50301------------ffffff"></embed>
        </object>
    </div>
</div>

<div id="content">
<h1>Деревья в программировании</h1>

<p><i>Многие реальные объекты имеют иерархическую структуру, например, схема предприятия или структура власти в
    государстве, генеалогическое дерево семьи или родословная некоторого человека. Для представления таких объектов и
    обработки связанной с ними информации удобна организация данных, отражающая структуру объектов. Если
    абстрагироваться от конкретного содержания элементов, то получится математический объект, называемый деревом.
    Рассмотрим некоторые способы представления и обработки деревьев.</i></p>

<h3>ПРЕДСТАВЛЕНИЕ ДАННЫХ С ПОМОЩЬЮ ДЕРЕВА</h3>

<p>Данные, имеющие иерархическую структуру, удобно представлять с помощью деревьев. Дерево представляет собой конечное
    множество элементов, называемых узлами, или вершинами. Вершины расположены на разных уровнях иерархии. На самом
    высоком уровне иерархии (пусть номер этого уровня 1) располагается единственный узел, называемый корнем.
    Каждый узел, расположенный на i-ом уровне, связан на более высоком (i1)-ом уровне с единственным узлом, который
    является исходным, или предком для данного узла. Каждый узел i-ого уровня может быть связан с одним или несколькими
    узлами на более низком (i+1)-ом уровне.
    Такие узлы (i+1)-ого уровня называются порожденными узлами, или потомками.
    Узлы, не имеющие порожденных, называются листьями. На плоскости узлы удобно изображать точками, узлы i-ого уровня
    связывать дугами с порожденными узлами (i+1)-ого уровня. Примером дерева может служить генеалогическое дерево, в
    котором порожденными узлами являются сыновья. На рисунке 1 изображено лишь два поколения потомков Александра
    Невского:
    сыновья и внуки.</p>

<p>Можно построить генеалогическое дерево своей семьи, выбрав в качестве корня дерева, например, прадедушку. С
    помощью дерева можно представить родословную некоторого человека. В таком дереве каждый узел имеет два порожденных,
    например, левый узел хранит данные о матери, правый об отце. На каком-то уровне информация о родственниках
    безвозвратно утеряна.</p>

<p>
    На рисунке 2 изображено дерево,
    узлы которого помечены буквами. Корнем этого дерева является узел A. Это
    единственный узел, расположенный на самом высоком уровне иерархии. Порожденные корнем узлы: C, D, E. Узел A для
    узлов C, D, E является исходным. Узлы
    G, I, K, L, M, E не имеют порожденных
    узлов и являются листьями. На рисунке 3
    изображены три дерева. Последнее дерево состоит лишь из одного узла корня
    E. Эти три дерева являются поддеревьями
    дерева, расположенного на рисунке 2.
    Корни этих поддеревьев связаны с единственным узлом A. Узел A расположен на

    более высоком уровне иерархии. Таким
    образом, порожденные узлы являются корнями поддеревьев данного дерева. При таком способе представления дерева
    достаточно иметь указатель на корень дерева
    для того, чтобы получить доступ к любой
    вершине дерева.
    Дерево можно определить как частный случай графа, а именно, дерево это
    связный граф без циклов. В [6] приведены примеры различных деревьев и способы их представления.
    Приведем рекурсивное определение
    дерева. Деревом называется конечное множество элементов D, состоящее из одного или нескольких элементов,
    удовлетворяющее условиям:
    1. Есть один выделенный элемент, называемый корнем дерева.
    2. Остальные элементы множества D содержатся в m попарно непересекающихся множествах D1, D2,..., Dm, каждое из
    которых является деревом. Деревья D1, D2,..., Dm являются поддеревьями выделенного корня.
</p>

<p>
    Дерево, изображенное на рисунке 2, можно представить в виде совокупности множеств (рисунок 4). Элемент A корень
    дерева, остальные элементы содержатся в трех попарно непересекающихся множествах {C, G, I, K}, {D, L, M}, {E}.
    Каждое из множеств, в свою очередь, является деревом. Рассмотрим множество {C, G, I, K}. Элемент C корень дерева,
    остальные элементы содержатся в трех попарно непересекающихся множествах
    {G},{I},{K}, каждое из которых дерево, состоящее лишь из одного элемента
    корня. Если узлы изобразить точками на
    плоскости, а корни дерева связать с корнями поддеревьев, то получим изображение, как на рисунке 2.
    При работе с деревьями удобно определить пустое дерево как дерево, не
    содержащее узлов.


</p>

<h3>БИНАРНЫЕ ДЕРЕВЬЯ И ИХ ПРЕДСТАВЛЕНИЕ</h3>

<p>Структуры данных и алгоритмы их обработки будут наиболее простыми в случае так называемых бинарных деревьев, то есть
    таких деревьев, каждый узел которых имеет не более двух порожденных узлов (левого и правого), и, соответственно, не
    более двух поддеревьев (левого и правого). На рисунке 5 представлены бинарные деревья. Деревья на рисунках
    5в и 5г различны, так как в первом случае узел D является левым порожденным для C, а во втором правым порожденным
    для
    C.
    Один из способов представления деревьев применяется в случае, если известно, что каждый элемент дерева имеет
    не более k поддеревьев при небольшом значении k. Тогда можно включить в каждый элемент k указателей на поддеревья.
    Наиболее частый случай k = 2, при котором дерево называют бинарным, а два
    поддерева левым и правым, соответственно. При таком способе представления достаточно иметь лишь указатель на
    корень дерева, чтобы получить доступ к любому элементу, спускаясь вниз по ука-
    зателям. Отсутствующее дерево представ-
    ляется пустым указателем.
</p>

<p>Узел дерева представляет собой запись, состоящую из трех полей, первое поле информационное, второе и третье
    указатели на левый и правый порожденные узлы (на корни ле- вого и правого поддеревьев). Если элемент име- ет тип
    node,
    то тип значения, называемого указателем на элемент node, записывается так: ^node. В разделе определения типов можно
    ввести синоним для типа ^node: tree=^node.
</p>

<p> Описание типов данных для бинарного дерева может выглядеть так:</p>

<pre class="sh_pascal" style="text-align:left;">
  type 
    elem_tree = char; { Тип значения в узле дерева }
    tree = ^node; { Указатель на узел дерева }
    node = record { Узел дерева }
      info : elem_tree; { Значение в узле }
      left,right : tree { Ссылки на левое и правое поддеревья }
    end;</pre>

<p>
    Обратите внимание, что сначала идет определение типа <strong>tree</strong>, так как тип <strong>tree</strong>
    используется при описании полей <strong>left</strong> и
    <strong>right</strong>. Конструкция ^Z - единственный описатель типа, который может содержать еще не определенный в
    программе тип Z.

<p>Если в программе переменная <strong>t</strong> будет описана так: <strong>var t: tree</strong>, то говорят, что t
    является указателем на элемент
    типа <strong>node</strong>. Переменная <strong>t</strong> может иметь значение <strong>nil</strong>. Это означает,
    что
    указатель не указывает ни на какой элемент.

<p>Переменная, на которую установлен указатель, обозначается t^, в нашем случае t^ имеет тип node. Получить доступ к
    полям переменной t^ можно следующим образом: t^.info, t^.left, t^.right.
    Если в программе описаны две переменные p и q (var p,q: tree), то после выполнения оператора присваивания p:=q оба
    указателя p и q будут установлены на одну и ту же переменную, а именно на ту, на которую первоначально был
    установлен
    указатель q.
    Значение переменной типа указателя может измениться в результате выполнения оператора присваивания

    p:=nil. Значение переменной типа указателя

    может измениться в результате выполнения стандартной процедуры new(p), при выполнении
    которой выделяется память под значение типа
    node, и указатель p устанавливается на новый,
    созданный элемент с неопределенными значениями полей. Если память не может быть выделена, то значение p становиться
    равным nil.
    Выполнение оператора присваивания
    p^:= q^ приведет к тому, что, хотя указатели
    установлены на разные переменные, значения
    этих переменных одинаковы.

<p><strong>Основные алгоритмы обработки бинарных деревьев </strong>

<p> При обработке деревьев удобно использовать рекурсию. Напомним, что при разработке рекурсивного
    алгоритма требуется обратить внимание на
    следующие моменты:

<p>1. Определить параметры, от которых зависит решение задачи.

<p>2. Решить задачу в тривиальном случае.

<p>3. Свести задачу к ней самой, но с другими, более «простыми», параметрами.

<h3><strong>Вычисление числа узлов бинарного дерева</strong></h3>

<p>
    При выбранном способе представления дерева для его задания достаточно
    иметь указатель на корень дерева, который и является единственным параметром.
    Если дерево пусто, то число его узлов равно 0. Это и есть решение задачи в тривиальном случае. Если же дерево не
    пусто,
    то число его узлов определяется как сумма числа узлов в левом поддереве и числа
    узлов в правом поддереве, увеличенная на
    единицу. Т.е. число узлов дерева можно определить рекурсивно следующим образом:
</p>

<p style="text-align: center">nnode(t)=1+nnode(tl)+nnode(tr),
</p>

<p>где <strong>t</strong> - исходное дерево, tl, tr - левое и
    правое поддеревья. Таким образом, решение задачи о числе узлов дерева сведено
    к решению той же самой задачи, но уже
    применительно к поддеревьям данного
    дерева. В каждом из поддеревьев число
    узлов меньше, чем в дереве. Именно в этом
    смысле понимаются в данном случае более «простые» параметры.
    Опишем функцию, которая для бинарного дерева, заданного указателем на
    корень, определяет количество узлов в
    дереве. </p>
<pre class="sh_pascal">
function nnode( t: tree ): integer;
begin
  if t=nil then 
    nnode := 0
  else 
    nnode := 1 + nnode(t^.left) + nnode(t^.right)
end;</pre>
<p><strong>Задача 1.</strong></p>

<p>1) Опишите рекурсивный алгоритм вычисления количества листьев бинарного дерева.

    В терминах генеалогического дерева это
    количество членов рода, не имеющих (или
    не имевших) сыновей. В терминах дерева
    родословной это те предки, про обоих родителей которых нам ничего не известно. </p>

<p>2) Опишите рекурсивный алгоритм вычисления количества ребер бинарного дерева.
    В терминах генеалогического дерева это
    число сыновей в роду, в терминах дерева
    родословной число известных предков. </p>

<p><strong>ОПРЕДЕЛЕНИЕ ВЫСОТЫ ДЕРЕВА
</strong></p>

<p>Высотой дерева называется максимальный из уровней всех узлов дерева.
    Высота пустого дерева равна 0, высота
    дерева, состоящего лишь из корня, равна
    1, высота дерева, изображенного на рисунке 6, равна 5. На рисунке 7 изображено дерево, где через A и B обозначены
    поддеревья, которые в общем случае могут быть и пустыми. При построении алгоритма можно рассуждать и так: как найти
    высоту дерева T, если известны высоты поддеревьев A и B? Для того чтобы
    найти высоту дерева T, надо взять максимальную из высот поддеревьев A и B и
    увеличить на 1.
</p>

<p>Рекурсивно высоту бинарного дерева t опишем так: </p>

<p>h(t)=max(h(tl),h(tr))+1, h(null)=0, где t исходное дерево, tl, tr левые и
    правые поддеревья, null пустое дерево. </p>

<p><strong>ПОИСК ЭЛЕМЕНТА В ДЕРЕВЕ </strong></p>

<p>Рассмотрим решение задачи поиска
    элемента в дереве. При решении этой задачи используются два параметра, один параметр задает дерево, второй тот
    элемент, который требуется найти в дереве.
    Как и ранее, тривиальное решение будет
    в случае, когда дерево пусто. В таком дереве нет узлов, следовательно, нет интересующего нас узла. Если дерево не
    пусто, то исследуется корень дерева. Если элемент, расположенный в корне дерева, совпадает с заданным элементом, то
    задача
    решена. В противном случае поиск элементов следует производить
    в поддеревьях A и B (рисунок 7). Порядок просмотра
    поддеревьев произволен.</p>

<p>Уровень 1. Опишите рекурсивный алгоритм, определяющий число элементов в
    бинарном дереве, равных заданному. </p>

<p>Уровень 2. Напишите рекурсивную
    процедуру определения числа узлов, находящихся на заданном уровне.</p>

<p><cite>Формат ввода: </cite></p>

<p>Заданный уровень k. Количество узлов в дереве n.</p>
<ol>
    <li>ЛП1 ПП1</li>
    <li>ЛП2 ПП2</li>
</ol>
<p align="left">n      ЛПп ППп<br>
    Примечание. ЛП - ссылка на левое под­дерево, ПП - ссылка на правое поддере­во, пустые поддеревья обозначаются 0.</p>

<p align="left"><cite>Формат вывода: </cite></p>

<p align="left">Число узлов на уровне k.</p>

<p align="left">Пример.<br>
    Дерево изображено на рисунке 8.</p>

<p><strong>ОБХОД ДЕРЕВА</strong></p>

<p> Одна из распространенных задач при работе с деревьями - выполнение некоторого действия p с каждым элементом дерева.
    Часто такую задачу называют задачей обхода дерева. При работе с деревьями операций [7] приводились алгоритмы обхода,
    позволяющие по дереву операций получить префиксную и постфиксную нотацию формул.</p>

<p> В качестве примера приведем левосторонний обход дерева. При левостороннем обходе сначала полностью обходится левое
    поддерево корня (если поддерево существует), затем действие p применяется к корню дерева, а затем обходится правое
    поддерево. При этом поддерево обходится левосторонним способом, то есть описанный алгоритм является рекурсивным.</p>

<p> Опишем алгоритм нахождения всех узлов дерева, расположенных на i-ом уровне (i &gt; 0). В этом случае задача имеет
    два параметра, один задает бинарное дерево, второй - номер уровня, на котором ищем вершины. Если дерево пусто, то
    вершин i-ого уровня в нем нет. Если же дерево не пусто и значение i равно 1, то элемент i-ого уровня - это корень
    дерева. Сведем решение задачи к ней самой, но с другими параметрами. Заметим, что все узлы i-ого уровня дерева t
    являются узлами (i -1)-ого уровня для левого и правого поддеревьев дерева t. Например, узлы D, E, F    являются
    узлами
    третьего уровня для дерева на рисунке 6 и узлами второго уровня для левого и правого поддеревьев, изображенных на
    рисунке 9.</p>

<p align="left">Уровень 2. После многих часов, проведенных в библиотеке, Виви составила свою родословную. Она получилась
    настолько обширной, что Виви запуталась в отношениях родства между своими предками. Помогите Виви разобраться в ее
    родословной. Для этого напишите программу, которая выписывает для двух предков Виви их отношение родства.
    Родословная
    задана бинарным де­ревом, причем для каждого человека в корне левого поддерева находится его мать, а в корне правого
    -
    отец.</p>

<p align="left"><cite>Формат ввода:</cite></p>
<pre style="text-align:left">
n (количество узлов дерева без учета корня)
имя 1   ЛП1 ПП1
имя 2   ЛП2 ПП2
...
имя n   ЛПn ППn
Имя предка 1   Имя предка 2</pre>
<p><cite>Формат вывода:</cite></p>
<pre style="text-align:left">
Отношение родства между предком 1 и предком 2.
</pre>
<p>

    <em>Примечание.</em> Для описания следует использовать только слова «мать, матери, сын, сына, отец, отца, дочь,
    дочери». Если имен, приведенных в примере окажется
    недостаточно, можно использовать следующие: Диди, Лулу, Зузу и т.д.) Дерево изображено на рисунке 10.</p>

<p><strong>БИНАРНОЕ ДЕРЕВО ПОИСКА</strong></p>

<p> Бинарное дерево удобно использовать для быстрого поиска данных. Будем считать, что элементы, которые будут
    организованы в бинарное дерево, снабжены числовым признаком, который назовем весом элемента. Элементы в дереве будем
    размещать таким образом, чтобы левое поддерево любого узла L содержало только те узлы, вес которых меньше, чем вес
    узла L, а правое поддерево - те узлы, вес которых больше или равен весу узла L. Такие де­ревья называют деревьями
    поиска или сортировки. На рисунке 11 изображено такое дерево.</p>

<p> Опишем алгоритм добавления элемента с заданным значением z в дерево поиска T. Сравнивается вес z с весом корня
    дерева T. Если вес z меньше, то элемент следует разместить в левом поддереве T, в противном случае - в правом. Далее
    поиск места для размещения элемента повторяется рекурсивно. Добавляемый элемент образует новый лист дерева.</p>

<p> При добавлении элементов со значениями 3 и 5 в дерево поиска, изображенное на рисунке 11, дерево примет вид,
    показанный на рисунке 12.</p>

<p>Опишем процедуру добавления в бинарное дерево поиска T элемента z. Считаем, что тип информационного поля элемента
    дерева - целый. </p>
<pre class="sh_pascal">
type elem_tree=integer;

procedure add_tree( var t: tree; z: elem_tree ); 
var p:tree;  
begin 
  if t=nil then begin 
    new(t); 
    tA.info := z; 
    tA.left := nil; 
    tA.right := nil 
  end else 
    if z &lt; tA.info then 
      add_tree(tA.left,z);  
    else  
      add_tree(tA.right,z)
end 
</pre>
<p>

    При левостороннем обходе бинарного дерева поиска элементы дерева образуют возрастающую (строго говоря - неубывающую)
    последовательность, левосторонний обход дерева на рисунке 12 обеспечит обработку вершин в порядке: 2 3 3 4 5 5 6 7 8
    9
    10. При правостороннем обходе значения будут расположены в порядке убывания.

<p><strong>ПОИСК С ВКЛЮЧЕНИЕМ</strong>

<p> При решении многих задач используется алгоритм, который получил название Поиск с включением. Согласно этому
    алгоритму элемент добавляется в дерево поиска лишь в тех случаях, если такого элемента в дереве не было. Таким
    образом, все элементы дерева различны.

<p><strong>Задача 4. </strong>

<p><strong><em>Уровень 1.</em></strong> Опишите два алгоритма (рекурсивный и нерекурсивный) поиска элемента с заданным
    весом в дереве поиска.

<p>
    <strong><em>Уровень 2.</em></strong> Задана последовательность ненулевых целых чисел, число 0 - признак конца.
    Напишите программу, которая формирует последовательность чисел в порядке убывания, причем каждое число встречается в
    этой последовательности лишь один раз.

<p><em>Указание.</em> По заданной последовательности постройте дерево поиска, используя процедуру, реализующую алгоритм
    реализующую алгоритм поиска с включением. Затем осуществите правосторонний обход построенного дерева.

<p><cite>Формат ввода: </cite>

<p>Последовательность натуральных чисел, завершаемая нулем.

<p><cite>Формат вывода: </cite>

<p>Отсортированная в порядке убывания последовательность без повторений.

<p align="left">Пример. </p>

<p align="left"><cite>Ввод: </cite>2 9 8 6 2 8 5 0</p>

<p align="left"><cite>Вывод: </cite>9 8 6 5 2</p>

<p align="left"><strong>Задача 5.</strong></p>

<p align="left"> Рассмотрим задачу, которая является упрощенным вариантом задачи о частотном словаре. Вместо анализа
    слов некоторого текста, будут анализироваться числа некоторой последовательности.</p>

<p align="left">Во входном потоке задана последовательность ненулевых целых чисел, число 0 считается признаком конца
    последовательности. Требуется написать программу, которая формирует две таблицы. В каждой из таблиц хранится число и
    количество его вхождений в последовательность. Первая таблица упорядочена в порядке возрастания чисел, вторая - в
    порядке убывания частот вхождения. Нам неизвестно количество различных чисел в последовательности, поэтому мы не
    знаем
    размера таблиц.</p>

<p>Можно поступить следующим
    образом: все числа последовательности организовать в бинарное дерево
    поиска. Для каждого числа проверять,
    встречалось ли оно ранее в последовательности. Если число встретилось
    впервые, то в дерево включить узел,
    одно из полей которого совпадает с
    числом, второе поле характеризует частоту вхождения и равно в данном случае 1. Если же рассматриваемое число уже в
    последовательности встречалось, то в дереве есть соответствующий этому числу узел. В этом случае узел надо найти и
    частоту вхождения увеличить на 1.</p>

<p> После просмотра всей последовательности будет построено дерево поиска, количество узлов которого равно количеству
    различных чисел в последовательности. С каждым числом хранится количество его вхождений в последовательность.
    Осуществляя левосторонний обход дерева, получим таблицу, числа в которой упорядочены по возрастанию. Рассмотрим
    последовательность чисел: 12 7 3 15 3 9 7 12 13 7 3 9 17 9 13 3 17 3 9 0. После просмотра всей последовательности
    будет построено дерево T, изображенное на рисунке 13. В каждом узле дерева первое число - элемент
    последовательности,
    второе число - частота вхождения в последовательность. При применении левостороннего обхода к построенному дереву T
    будут выведены значения, представленные в таблице 1.</p>

<p>Для того чтобы построить таблицу в порядке убывания частот, можно по дереву поиска построить дерево, элементы
    которого упорядочены по частоте вхождения, а затем применить к нему</p>

<p>&nbsp;</p>

<p align="left">Таблица 1</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p align="left">&nbsp;</p>

<p>

<p>

<p>

<p align="left">&nbsp;</p>

<h3>сновные определения </h3>

<p id="id_159">Существует довольно много равносильных определений <span class="keyword">деревьев</span>, вот лишь
    некоторые из них.</p>

<div class="lecture_mark" id="mark_159"></div>
<ol id="id_160">
    <li><span class="keyword">Дерево</span> - это связный <span class="keyword">граф</span> без <span class="keyword">циклов</span>.
    </li>
    <li><span class="keyword">Дерево</span> - это связный <span class="keyword">граф</span>, в котором при <span
            class="texample">N</span> <span class="keyword">вершинах</span> всегда ровно <span
            class="texample">N-1</span>
        <span class="keyword">ребро</span>.
    </li>
    <li><span class="keyword">Дерево</span> - это <span class="keyword">граф</span>, между любыми двумя <span
            class="keyword">вершинами</span> которого существует ровно один <span class="keyword">путь</span>.
    </li>
</ol>
<div class="lecture_mark" id="mark_160"></div>
<p id="id_166">Аналогичным образом определяется и <strong>ориентированное</strong> <span class="keyword">дерево</span> -
    как <span
            class="keyword">орграф</span>, в котором между любыми двумя <span class="keyword">вершинами</span>
    существует не
    более одного <span class="keyword">пути</span>.</p>

<div class="lecture_mark" id="mark_167"></div>
<p align="left" id="id_168">

<div class="lecture_mark" id="mark_168"></div>
<p id="id_169">Мы будем изучать и использовать только один частный случай ориентированных <span
        class="keyword">деревьев</span> - <span class="keyword">корневые деревья</span> (см. <a href="#image.11.12">рис.
    11.12</a>).</p>

<div class="lecture_mark" id="mark_169"></div>
<p id="id_170"><span class="keyword_def">Корневое дерево</span> - это ориентированное <span
        class="keyword">дерево</span>, в котором можно выделить <span class="keyword">вершины</span> трех видов: <span
        class="keyword">корень</span>, <span class="keyword">листья</span> (другое их название: <span
        class="keyword_def">терминальные вершины</span>)
    и остальные <span class="keyword">вершины</span> (<span class="keyword_def">нетерминальные</span>); причем должны
    выполняться два обязательных условия:</p>

<div class="lecture_mark" id="mark_170"></div>
<ol id="id_171">
    <li>из <span class="keyword">листьев</span> не выходит ни одна <span class="keyword">дуга</span>; из других <span
            class="keyword">вершин</span> может выходить сколько угодно <span class="keyword">дуг</span>;
    </li>
    <li>в <span class="keyword">корень</span> не заходит ни одна <span class="keyword">дуга</span>; во все
        остальные <span
                class="keyword">вершины</span> заходит ровно по одной <span class="keyword">дуге</span>.
    </li>
</ol>
<div class="lecture_mark" id="mark_171"></div>
<p id="id_174">Традиционно в математике и в родственных ей науках (в том числе и в теоретическом программировании) <span
        class="keyword">деревья</span> "растут" вниз головой: это делается просто для удобства наращивания <span
        class="keyword">листьев</span> в случае необходимости. Таким образом, на рисунках <span
        class="keyword">корень</span> <span class="keyword">дерева</span> оказывается самой верхней <span
        class="keyword">вершиной</span>,
    а <span class="keyword">листья</span> - самыми нижними.</p>

<div class="lecture_mark" id="mark_174"></div>
<p id="id_175"><span class="keyword_def">Предок</span> <span class="keyword">вершины</span> <span
        class="texample">v</span> - это <span class="keyword">вершина</span>, из которой исходит <span
        class="keyword">дуга</span>, заходящая в <span class="keyword">вершину</span> <span
        class="texample">v</span>. <span
        class="keyword">Потомок</span> <span class="keyword">вершины</span> <span class="texample">v</span> - это <span
        class="keyword">вершина</span>, в которую заходит <span class="keyword">дуга</span>, исходящая из <span
        class="keyword">вершины</span> <span class="texample">v</span>. В этих терминах можно дать другие определения
    понятиям <span class="keyword">корень</span> и <span class="keyword">лист</span>: у <span
            class="keyword">корня</span>
    нет <span class="keyword">предков</span>, у <span class="keyword">листа</span> нет <span
            class="keyword">потомков</span>.</p>

<div class="lecture_mark" id="mark_175"></div>
<p id="id_180"><span class="keyword_def">Бинарное дерево</span> - это <span class="keyword">корневое дерево</span>,
    каждая <span class="keyword">вершина</span> которого имеет не более двух <span class="keyword">потомков</span>. В
    таком случае иногда говорят о <strong>левом</strong> <span class="keyword">потомке</span> и <strong>правом</strong>
    <span class="keyword">потомке</span>
    для текущей <span class="keyword">вершины</span>.</p>

<div class="lecture_mark" id="mark_180"></div>
<p id="id_181"><span class="keyword_def">Высота</span> <span class="keyword">корневого дерева</span> - это максимальное
    количество <span class="keyword">дуг</span>, отделяющих <span class="keyword">листья</span> от корня. Если <span
            class="keyword">дерево</span> не взвешенное, то его <span class="keyword">высота</span> - это просто <span
            class="keyword">расстояние</span> от корня до самого удаленного <span class="keyword">листа</span>.</p>

<div class="lecture_mark" id="mark_181"></div>
<p id="id_182">И в заключение мы приведем определение, связывающее произвольные <span class="keyword">графы</span> с
    <span class="keyword">деревьями</span> более плотно.</p>

<div class="lecture_mark" id="mark_182"></div>
<p id="id_183"><span class="keyword_def">Каркас</span> <span class="keyword">графа</span> - это <span class="keyword">дерево</span>,
    полученное после выбрасывания из <span class="keyword">графа</span> некоторых ребер (см. <a href="#image.11.13">рис.
        11.13</a>). </p>

<div class="lecture_mark" id="mark_183"></div>
<div class="lecture_mark" id="mark_184"></div>
<p id="id_185">Примером <span class="keyword">каркаса</span> является (<span class="keyword">корневое</span>) <span
        class="keyword">дерево</span> кратчайших <span class="keyword">путей</span> от некоторой выделенной <span
        class="keyword">вершины</span> (она будет корнем <span class="keyword">каркаса</span>) до всех остальных <span
        class="keyword">вершин</span> <span class="keyword">графа</span>.</p>

<p><img src="trees/Info3.3.0_clip_image002.gif" alt="F" width="238" height="175"></p>

<p>Мы рассмотрели бинарное дерево и алгоритмы работы с ним. Представленные нами алгоритмы анализировали, в основном,
    структуру дерева и, в меньшей мере, элементы, из которых дерево строилось.</p>

<p> Дерево поиска использовали для работы с данными, на которых задан порядок. Многие алгоритмы, описанные для бинарных
    деревьев, применимы и в случае деревьев поиска. Некоторые алгоритмы для дерева поиска были изменены. Поиск элемента
    в
    дереве поиска можно делать эффективнее, чем просто в бинарном дереве. Были добавлены новые алгоритмы, присущие
    только
    деревьям поиска: добавление элемента в дерево поиска, построение дерева поиска, поиск с включением и др.</p>

<p>Дерево операций использовалось для представления формул. Многие алгоритмы, описанные для бинарных деревьев, применимы
    и для деревьев операций, причем, для деревьев операций алгоритмы имеют свою интерпретацию. Например, поиск числа
    листьев в бинарном дереве можно трактовать как поиск операндов в дереве операций. Соответствующие обходы бинарных
    деревьев позволяют получать формулы в бесскобочной записи. Специфичными для деревьев операций являются алгоритмы:
    построение по формуле дерева операций, вывод формулы в инфиксной записи с необходимыми скобками, вычисление значения
    формулы, дифференцирование формулы, выполнение частичных преобразований и др.</p>

<p> Следуя технологии объектно-ориентированного программирования, можно создать объект «бинарное дерево», который
    является родителем двух других объектов: «дерево поиска» и «дерево операций». Потомки наследуют методы родителя. При
    необходимости методы родителя могут быть переопределены. Каждый потомок может иметь свои собственные методы.
    Объектно-ориентированное программирование - отдельная интересная тема, а мы заметим лишь, что и отношения между
    объектами отображаются с помощью дерева, например, изображенного на рисунке 27.</p>

<p align="left"><strong>Литература</strong>.</p>
<ol>
    <li>Вирт Н. Алгоритмы+структуры данных=программы. М.: Мир, 1985, 392 с.</li>
    <li>Дмитриева М.В., Кубенский А.А. Элементы современного программирования. СПб., 1991.</li>
    <li>Епанешников А., Епанешников В. Программирование в среде Turbo Pascal 7.0. М.,1993.</li>
    <li>Дмитриева М.В., Кубенский А.А. Турбо Паскаль и Турбо Си: построение и обработка структур данных. СПб., 1996.
    </li>
    <li>Касьянов В.Н., Сабельфельд В.К. Сборник задач по практикуму на ЭВМ. М., 1986.</li>
    <li>Черкасова П.Г. Компьютер и графы. Компьютерные инструменты в образовании, № 6, 1999 г.</li>
    <li>Дмитриева М.В., Поздняков С.Н. Формулы, формулы, формулы... Компьютерные инструменты в образовании, № 2, 2000 г.
    </li>
</ol>
</div>

</body>

</html>