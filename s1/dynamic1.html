<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>Динамическое программирование</title>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
    <script type="text/javascript" src="../syntax/sh_main.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_pascal.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_python.js"></script>
    <script type="text/javascript" src="../syntax/sh_basic.js"></script>
    <link type="text/css" rel="stylesheet" href="../style/sh_nedit.css">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});



























    

    </script>
    <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>
<body onLoad="sh_highlightDocument();">
<div style="width:80%;">
    <div style="float:right;">
        <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
                codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0"
                width="100"
                height="50">
            <param name="movie" value="../audio/a_smsqulh3n.swf">
            <param name="bgcolor" value="fff">
            <param name="FlashVars" value="src=9094e666f613f513f50301------------ffffff">
            <param name="autoplay" value="false">
            <embed src="../audio/a_smsqulh3n.swf" bgcolor="fff"
                   width="100" height="70" type="application/x-shockwave-flash"
                   pluginspage="http://www.macromedia.com/go/getflashplayer"
                   FlashVars="src=9094e666f613f513f50301------------ffffff"></embed>
        </object>
    </div>
</div>

<div id="content">
<h1>Динамическое программирование: теория</h1>

<ul class="tags">
    <li><a href="#">Динамика</a></li>
</ul>

<p>Словосочетание динамическое программирование впервые было использовано в 1940-х годах Р. Беллманом для описания
    процесса нахождения решения задачи, где ответ на одну задачу может быть получен только после решения задачи,
    «предшествующей» ей.
    В 1953 г. он уточнил это определение до современного. Вклад Беллмана в динамическое программирование был увековечен
    в названии уравнения Беллмана, центрального результата теории динамического программирования, который
    переформулирует
    оптимизационную задачу в рекурсивной форме.
    Слово «программирование» в словосочетании «динамическое программирование» в действительности к традиционному
    программированию (написанию кода) почти никакого отношения не имеет и происходит от словосочетания «математическое
    программирование», которое является синонимом слова «оптимизация». Поэтому слово «программа» в данном контексте
    скорее означает оптимальную последовательность действий для получения решения задачи. К примеру, определенное
    расписание
    событий на выставке иногда называют программой. Программа в данном случае понимается как допустимая
    последовательность
    событий. </p>

<p>Идея метода динамического программирования состоит в сведении (с помощью рекуррентных соотношений) исходной задачи к
    решению некоторых ее подзадач «меньшего размера» и использовании табличной техники для сохранения уже найденных
    ответов [2]. Рассказ о методе динамического программирования уместно начинать с легенды о лестнице фараона [12].
    Золотую лестницу фараона из девяти ступеней необходимо было модернизировать, уменьшив количество ступеней в лестнице
    до четырех и используя небольшое количество золота, имеющееся в казне для наращивания ступеней. Золота было так
    мало,
    а всех вариантов модернизации так много, что не сносить бы несчастному казначею головы, если бы не его умный
    друг-жрец.  Жрец, прекрасно владея чудесным методом динамического программирования, сумел за короткий срок, не
    рассматривая всех вариантов, найти оптимальное решение и выгадать себе остаток золота из казны фараона. <br>
    Разбор задач по данному методу легче воспринимается с самой известной и простой задачи про маршрут [13].</p>

<p><strong><cite>Задача 1.</cite></strong> В таблице $A$ размерности $N \times N$ клетки заполнены случайным образом
    цифрами от 0 до 9.
    Найти маршрут из левой верхней клетки $A(1, 1)$ в правую нижнюю клетку $A(N, N)$ такой, что:</p>
<ul>
    <li>он будет состоять из отрезков, соединяющих центры клеток, имеющих общую сторону;</li>
    <li>длина маршрута минимально возможная;</li>
    <li>из всех маршрутов, удовлетворяющих вышеуказанным условиям, искомый маршрут тот, сумма цифр в клетках которого
        максимальна.
    </li>
</ul>
<p>Вывести маршрут как последовательность пар координат клеток, через которые он проходит (первая координата – номер
    строки, вторая – номер столбца). </p>

<p>Очевидно, что все кратчайшие маршруты идут только сверху вниз и слева направо и длина их $2N-1$. При достаточно
    большом $N$ таких маршрутов огромное количество, что полным перебором решить данную задачу практически
    невозможно.</p>

<p>Итак, рассмотрим аналогичную задачу для всевозможных прямоугольных подтаблиц размеров $(N-I+1) \times (N-J+1)$
    исходной таблицы (при $I, J = 1, 2, ...$) и построим вспомогательную таблицу $B$ размером $N \times N$ с суммой
    цифр, через которые проходит оптимальный путь в такой таблице.<br>
    Построение вспомогательной таблицы $B$ необходимо начать с конца таблицы $A$, что приведет к следующим формулам
    (рис. 1): </p>
<img src="dynamic1/Info3.4.0_clip_image001.png" alt="Картинка">
<ol>
    <li>$B(N, N) = A(N, N)$<br>
        последняя клетка обязательно входит в маршрут
    </li>
    <li>$B(N, J) = B(N,J+1) + A (N, J)$ при $J = N-1, N-2, ... , 1$ <br>
        если маршрут вышел в последнюю строку таблицы, то он обязательно будет проходить до конца по последней строке,
        так как он кратчайший
    </li>
    <li>$B(I, N) = B(I+1, N) + A (I, N)$ при $I = N-1, N-2, ..., 1$ <br>
        если маршрут вышел в последний столбец таблицы, то он обязательно будет проходить до конца по последнему столбцу
    </li>
    <li>$B(I, J) = max (B(I+1, J),  B(I, J+1)) + A (I, J)$ при $I&lt;N$ и $J&lt;N$ <br>
        внутри таблицы в маршрут будет входить та клетка из последующего столбца или последующей строки, в которой сумма
        цифр больше
    </li>
</ol>
<p>Оптимальный маршрут легко получить, двигаясь по полученной вспомогательной таблице из левого верхнего в правый нижний
    угол и выбирая направление в сторону той клетки, где записано большее число.</p>

<p><cite>Программа</cite><cite> .1</cite>:<br>
    RANDOMIZE TIMER<br>
    CLS<br>
    INPUT &quot;Введите размерность N: &quot;; n<br>
    DIM a(n, n), b(n, n)<br>
    FOR i = 1 TO n<br>
    FOR j = 1 TO n<br>
    a(i, j) = INT(RND * 10)<br>
    PRINT a(i, j);<br>
    NEXT j<br>
    PRINT<br>
    NEXT i<br>
    'Формирование дополнительной матрицы<br>
    b(n, n) = a(n, n)<br>
    FOR i = n - 1 TO 1 STEP -1<br>
    b(i, n) = b(i + 1, n) + a(i, n)<br>
    b(n, i) = b(n, i + 1) + a(n, i)<br>
    NEXT i<br>
    FOR i = n - 1 TO 1 STEP -1<br>
    FOR j = n - 1 TO 1 STEP -1<br>
    b(i, j) = max(b(i + 1, j), b(i, j + 1)) + a(i, j)<br>
    NEXT j, i<br>
    PRINT<br>
    PRINT &quot;Сумма чисел на всем кратчайшем пути = &quot;; b(1, 1)<br>
    'Путь ищется обратным проходом<br>
    PRINT &quot;( 1; 1)&quot;;<br>
    i = 1: j = 1<br>
    WHILE (i &lt;&gt; n) OR (j &lt;&gt; n)<br>
    IF i = n THEN                                    'Если дошли до нижней границы<br>
    j = j + 1<br>
    ELSE<br>
    IF j = n THEN                       'Если дошли до правой границы<br>
    i = i + 1<br>
    ELSE<br>
    IF b(i + 1, j) &gt; b(i, j + 1) THEN i = i + 1 ELSE j = j + 1<br>
    END IF<br>
    END IF<br>
    PRINT USING &quot; - (##;##)&quot;; i; j;<br>
    WEND</p>

<p>FUNCTION max (a, b)<br>
    IF a &gt; b THEN max = a ELSE max = b<br>
    END FUNCTION</p>

<p><strong><cite>Задача 2</cite>. «Акирема». </strong>(Областная олимпиада 1998).<br>
    В государстве Акирема алфавит состоит из букв американского языка. Каждый акиремец (житель) имеет право пополнить
    словарь своего языка новым словом.<br>
    Слово формируется по следующим правилам:</p>
<ul>
    <li>Предлагается N известных слов (длина каждого слова не превосходит M);</li>
    <li>Слова выписываются друг под другом с выравниванием по левому краю;</li>
    <li>Из каждого слова выбирается по одной букве непрерывной цепочкой, т.е. буквы должны граничить друг с другом по
        вертикали или по диагонали;
    </li>
    <li>Полученное таким образом слово длины N должно иметь максимальную сумму кодов ASCII каждой буквы.</li>
</ul>
<p>Какое новое слово может  сформировать акиремец по предложенным словам.</p>

<p><cite>Примечание.</cite> Данные вводятся из файла с именем INPUT.TXT. В файле они заданы так: числа N и M – на первой
    строке через разделитель, каждое слово задаётся с новой строки.<br>
    Вывод осуществляется на экран или в файл с именем OUTPUT.TXT.</p>

<p><span style="text-decoration: underline;">Пример:</span> из слов<br>
    A <strong>P</strong> P L E<br>
    <strong>W</strong> I N D O W S<br>
    M <strong>O</strong> U S E<br>
    B <strong>Y</strong> T E</p>

<p>должно получиться слово <strong>PWOY</strong>. </p>

<p><cite>Указание</cite>. Задача легко сводится к предыдущей. Строится матрица A размера NxM, где N – количество слов, а
    M –
    количество букв в самом длинном слове (табл. 1). Массив первоначально заполняется кодами ASCII букв каждого слова,
    расположенного в матрице по строкам с выравниванием по левой стороне (для коротких слов в матрице на местах
    отсутствия
    букв проставляются нули). </p>

<p style="text-align: center">Таблица 1</p>

<div>
    <table border="1">
        <tr>
            <td><br>
                65
            </td>
            <td><p>80</p></td>
            <td><p>80</p></td>
            <td><p>76</p></td>
            <td><p>69</p></td>
            <td><p>0</p></td>
            <td><p>0</p></td>
        </tr>
        <tr>
            <td><p>87</p></td>
            <td><p>73</p></td>
            <td><p>78</p></td>
            <td><p>68</p></td>
            <td><p>79</p></td>
            <td><p>87</p></td>
            <td><p>83</p></td>
        </tr>
        <tr>
            <td><p>77</p></td>
            <td><p>79</p></td>
            <td><p>85</p></td>
            <td><p>83</p></td>
            <td><p>69</p></td>
            <td><p>0</p></td>
            <td><p>0</p></td>
        </tr>
        <tr>
            <td><p>66</p></td>
            <td><p>89</p></td>
            <td><p>84</p></td>
            <td><p>69</p></td>
            <td><p>0</p></td>
            <td><p>0</p></td>
            <td><p>0</p></td>
        </tr>
    </table>
</div>
<p>Затем массив преобразуется по следующему правилу (табл. 2):</p>
<ul>
    <li>последняя строка в матрице остается без изменений;</li>
    <li>начиная с предпоследней строки и до первой, числа в матрице заменяются так:</li>
    <li>A (I, J) = max (A (I-1, J), A (I-1, J+1)) + A (I, J) при I = N-1, N-2, …, 1 и J = 1</li>
    <li>A (I, J) = max (A (I-1, J), A (I-1, J-1)) + A (I, J) при I = N-1, N-2, …, 1 и J = M</li>
    <li>A (I, J) = max (A (I-1, J-1), A (I-1, J), A (I-1, J+1)) + A (I, J) при I = N-1, …, 1 и J = 2, 3, …, M-1.</li>
</ul>
<p style="text-align: center">Таблица 2 </p>

<div>
    <table border="1">
        <tr>
            <td><br>
                320
            </td>
            <td><p>335</p></td>
            <td><p>332</p></td>
            <td><p>328</p></td>
            <td><p>315</p></td>
            <td><p>0</p></td>
            <td><p>0</p></td>
        </tr>
        <tr>
            <td><p>255</p></td>
            <td><p>247</p></td>
            <td><p>252</p></td>
            <td><p>242</p></td>
            <td><p>246</p></td>
            <td><p>225</p></td>
            <td><p>83</p></td>
        </tr>
        <tr>
            <td><p>166</p></td>
            <td><p>168</p></td>
            <td><p>174</p></td>
            <td><p>167</p></td>
            <td><p>138</p></td>
            <td><p>0</p></td>
            <td><p>0</p></td>
        </tr>
        <tr>
            <td><p>66</p></td>
            <td><p>89</p></td>
            <td><p>84</p></td>
            <td><p>69</p></td>
            <td><p>0</p></td>
            <td><p>0</p></td>
            <td><p>0</p></td>
        </tr>
    </table>
</div>
<p>В первой строке матрицы ищется наибольший элемент – это и есть искомая максимальная сумма кодов ASCII. Обратным
    ходом, выбирая всегда наибольшее значение, необходимо двигаться сверху вниз (с первой строки до последней),
    составляя
    строку из соответствующих букв. Искомое слово найдено - <strong>PWOY</strong>. </p>

<p><cite>Программа 2</cite>:<br>
    DEFINT A-Z<br>
    OPEN &quot;input.txt&quot; FOR INPUT AS #1<br>
    INPUT #1, n, m<br>
    DIM Word$(1 TO n), Marks(0 TO n, 0 TO m + 1)</p>

<p>FOR i = 1 TO n<br>
    INPUT #1, Word$(i)<br>
    FOR j = 1 TO LEN(Word$(i))<br>
    Marks(i, j) = ASC(MID$(Word$(i), j, 1)) + max(Marks(i - 1, j - 1), _<br>
    Marks(i - 1, j), Marks(i - 1, j + 1))<br>
    NEXT<br>
    NEXT</p>

<p>k = 1<br>
    FOR i = 2 TO LEN(Word$(n))<br>
    IF Marks(n, i) &gt; Marks(n, k) THEN k = i<br>
    NEXT</p>

<p>FOR i = n TO 1 STEP -1<br>
    s$ = MID$(Word$(i), k, 1) + s$<br>
    IF Marks(i - 1, k - 1) &gt; Marks(i - 1, k + 1) THEN k = k - 1<br>
    IF Marks(i - 1, k + 1) &gt; Marks(i - 1, k) THEN k = k + 1<br>
    NEXT<br>
    PRINT s$</p>

<p>FUNCTION max (a, b, c)<br>
    IF a &gt; b THEN<br>
    IF a &gt; c THEN max = a ELSE max = c<br>
    ELSE<br>
    IF b &gt; c THEN max = b ELSE max = c<br>
    END IF<br>
    END FUNCTION</p>

<p><strong><cite>Задача 3</cite>. «INTERNETомания». </strong>(Районная олимпиада 1999)</p>

<p><img src="dynamic1/Info3.4.0_clip_image002.jpg" alt="1" width="142" height="133">Компания
    «Питерские
    сети» проводит подключение к сети INTERNET N-этажных домов. На каждом этаже компьютеры подключаются к концентратору
    (HUB) по топологии «звезда», т.е. каждый компьютер соединяется с концентратором отдельным кабелем (рис. 2).<br>
    Количество квартир на каждом этаже равно K (для упрощения предполагается, что квартиры расположены на одной прямой,
    и
    нумерация квартир идет слева направо). Расстояние между соседними квартирами и этажами одинаково. Схема дома
    представлена в виде прямоугольной таблицы, строки которой – этажи, а столбцы – квартиры. Квартиры, имеющие
    компьютер,
    обозначаются 1 (единицей), а остальные 0 (нулями). Переход с одного этажа на другой возможен только в ближайшие
    квартиры (рис. 3).</p>

<p><img src="dynamic1/internet2.jpg" alt="2-ая картинка к задаче INTERNETомания" width="233" height="92"></p>

<p>Требуется написать программу, которая выведет номера квартир, начиная с первого этажа, в которых должны быть
    расположены HUB’ы, при условии, что общая длина кабеля, соединяющего все компьютеры в сети, минимальна.</p>

<p><cite>Примечание</cite>.  Концентраторы (HUB) могут располагаться и в тех квартирах, где нет компьютеров.</p>

<p><cite>Формат входных данных:</cite><br>
    Входные данные расположены в текстовом файле с именем INPUT.TXT в следующем порядке:</p>
<ul>
    <li>первая строка содержит числа N (&le; 14) и K (&le; 8);</li>
    <li>последующие строки – это строки таблицы, состоящей из нулей и единиц и изображающей схему дома с компьютерами.
    </li>
</ul>
<p><cite>Формат выходных данных:</cite><br>
    Результат работы программы выводится в файл OUTPUT.TXT и представляет собой последовательность номеров квартир,
    начиная с первого этажа, в которых должны располагаться концентраторы HUB.<img
            src="dynamic1/Info3.4.0_clip_image002_0000.jpg"
            alt="1" width="148" height="139"
            ></p>

<p><cite>Пример файла INPUT.TXT (рис. 4):</cite></p>

<h3>5 3</h3>

<h3>1 1 0                {5-й этаж}</h3>

<h3>0 0 1                {4-й этаж}</h3>

<h3>1 1 1                {3-й этаж}</h3>

<h3>0 1 0                {2-й этаж}</h3>

<h3>1 0 0                {1-й этаж}</h3>

<p>
    &nbsp;

<div><cite>Пример файла OUTPUT.TXT</cite>
<pre>  1
  5
  8
  12
  14 </pre>
    <strong></strong>
</div>
</div>
<p><span style="text-decoration: underline;">Указание</span>. Задача легко сводится к предыдущей.</p>

<p>Еще одно из сравнительно новых применений динамического программирования – молекулярная биология, где базы данных
    содержат биологические последовательности (ДНК, РНК, белков), насчитывающие в сумме многие миллионы «букв», так что
    в
    их анализе не обойтись без компьютеров. Молекулы ДНК, содержащие генетическую информацию, - это длинные слова из
    четырех букв (А, Г, Ц, Т). В процессе эволюции, в результате мутаций последовательности меняются: одна буква может
    замениться на другую, выпасть, а может добавиться новая. Возникают жизненно важные задачи: насколько похожи два
    фрагмента, каким наименьшим числом превращений можно один из них получить из другого, найти подпоследовательность
    наибольшей длины, входящую в тот или другой фрагмент.</p>

<p><strong><span style="text-decoration: underline;">Задача 4</span>. </strong>Заданы два слова длиной N и M
    соответственно (N, M \le 30). Найти
    подпоследовательность максимальной длины, входящую в то и другое слово (подпоследовательность не является
    непрерывной).</p>

<h2>Задачи на динамическое программирование</h2>

<h3>Числа Фибоначчи</h3>

<p>Вычислить $N$-ое число в последовательности Фибоначчи, — 1, 1, 2, 3, 5, 8, … — в которой первые два члена равны
    единице, а все остальные представляют собой сумму двух предыдущих.<br>
    <cite>Входные данные:</cite> Целое: $1 \le N \le 70$.<br>
    <cite>Выходные данные:</cite> Одно число — $N$-ый член последовательности.</p>

<p><strong>Решение:</strong> условие задачи в виде формулы (динамический переход): $F_1=1$, $F_2=2$,
    $F_i=F_{i-1}+F_{i-2}, i \ge 3$.
</p>
<pre class="sh_pascal">
const MaxN = 70;
var i,N : Integer;
    F : Array [1..MaxN] of Int64; { Массив для хранения вычисленных значений F }
begin
  { Чтение входных данных }
  Read(N);
  { Проверка корректности входных данных }
  assert( (1 <= N) and (N <= MaxN) );
  { Инициализация "динамики", первые 2 значения F }
  F[1]:=1;  F[2]:=1;
  { Общий шаг динамики: в цикле вычисляем значения F }
  for i:=3 to N do
    F[i] := F[i-1] + F[i-2];
  { Вывод результата }
  write(F[N]);
end.</pre>

<h3>Мячик на лесенке</h3>

<p>На вершине лесенки, содержащей $N$ ступенек, находится мячик, который начинает прыгать по ним вниз, к основанию.
    Мячик может прыгнуть на следующую ступеньку, на ступеньку через одну или через 2. (То есть, если мячик лежит на 8-ой
    ступеньке, то он может переместиться на 5-ую, 6-ую или 7-ую.).
    Определить число всевозможных &quot;маршрутов&quot; мячика с вершины на землю.<br>
    <cite>Входные данные:</cite> Целое: $1 \le N \le 40$.<br>
    <cite>Выходные данные:</cite> Одно число — количество маршрутов.</p>
<table class="examples">
    <thead>
    <th>Входной файл</th>
    <th>Выходной файл</th>
    <tbody>
    <tr>
        <td>4</td>
        <td>7</td>
    </tr>
    <tr>
        <td>39</td>
        <td>12960201916</td>
    </tr>
    <tr>
        <td>13</td>
        <td>1705</td>
    </tr>
</table>
<p><strong>Решение:</strong> <br>
    $D_i$ - количество всевозможных способов попасть на $i$-ую ступеньку.<br>
    $D_1=1$ - только один способ попасть на первую ступеньку. <br>
    $D_2=2$ - попасть на 2-ую можно 2-мя способами: прыгнув на неё сразу или прыгнув с 1-ой ступеньки. <br>
    $D_3=4$ - попасть на 3-ую можно 4-мя способами:<br>
    1) прыгнув на неё сразу<br>
    2) прыгнув на 1-ую, потом на 3-ю<br>
    3) прыгнув на 2-ую, потом на 3-ю<br>
    3) прыгнув на 1-ую ступеньку, потом на 2-ую, потом на 3-ю. <br>
    $D_i=D_{i-1}+D_{i-2}+D_{i-3}, i \ge 4$ - на ступеньки начиная с 4-ой можно попасть с 3-х предыдущих.
    Мы знаем, сколькими способами можно попасть на каждую ступеньку из предыдущих.
    <b>Общий принцип:</b> Количество вариантов как попасть в какое-то состояние равно сумме количеств вариантов как
    попасть в предыдущие состояния.</p>

<pre class="sh_pascal">
var I,N : integer;
    D : array [1..40] of Int64;
begin
  read(N);
  D[1]:=1; D[2]:=2; D[3]:=4;
  for I:=4 to N do
    D[I] := D[I-1] + D[I-2] + D[I-3];
  writeln(D[N])
end.</pre>

<h3>Черепашка</h3>

<p>На квадратной доске расставлены целые неотрицательные числа. Черепашка, находящаяся в левом верхнем углу, мечтает
    попасть в правый нижний. При этом она может переползать только в клетку справа или снизу и хочет, чтобы сумма всех
    чисел, оказавшихся у нее на пути, была бы максимальной. Определить эту сумму.</p>
<cite>Вход:</cite> Первая строка — $N$ — размер доски ($1 \leq N \leq 50$). <br>
Далее следует $N$ строк, каждая из которых содержит $N$ целых чисел, представляющие числа на доске.<br>
<cite>Выход:</cite> Одно число — максимальная сумма.

<table border="1">
    <tr>
        <td><strong>Тест</strong></td>
        <td><strong>Ответ</strong></td>
    </tr>
    <tr>
        <td width="170"><p>3<br>
            2 6 0<br>
            5 0 6<br>
            4 1 2</td>
        <td width="180"><p>16</p></td>
    </tr>
</table>
<p><strong>Решение:</strong>
    $S_{ij}$ - максимальная набранная сумма, если черепашка находится в клетке $i,j$<br>
    Динамический переход: $S_{ij}=max(S_{i-1,j},S_{i,j-1})+A_{i,j}$<br>
    Инициализация: $S_{i,0} = 0$ $S_{0,j} = 0$<br>
    Ответ: $S_{N,N}$

<h3>Робот</h3>

<p>В исследовательской лаборатории фирмы Robots&amp;Co разработали новую модель робота. Главной особенностью данной
    модели робота является то, что он работает по заранее заданной программе, в которой могут присутствовать команды:
    сделать шаг на Юг, на Север, на Восток или на Запад. Робот исполняет программу строго последовательно и, дойдя до
    конца программы, останавливается. Специалисты из Robots&amp;Co заинтересовались вопросом, сколько существует
    различных
    программ, состоящих из K инструкций, таких, что робот, выйдя из начала координат, придет в точку с координатами (X,
    Y). Оси координат располагаются параллельно сторонам света, и единица измерения, соответствует одному шагу робота.
    Напишите программу, которая дает ответ на этот вопрос.<br>
    <cite>Входные данные:</cite><br>
    Во входном файле находятся три числа K, X и Y (0 \le K \le 16, |X|, |Y| \le 16), разделенные пробелами.<br>
    <cite>Выходные данные:</cite> <br>
    В выходной файл ваша программа должна поместить одно число — количество программ для робота.</p>
<table border="1">
    <tr>
        <td width="170"><br>
            <strong>e.in</strong></td>
        <td width="180"><p><strong>e.out</strong></p></td>
    </tr>
    <tr>
        <td width="170"><p>5 -2 -3</p></td>
        <td width="180"><p>10</p></td>
    </tr>
    <tr>
        <td width="170"><p>16 16 15</p></td>
        <td width="180"><p>0</p></td>
    </tr>
    <tr>
        <td width="170"><p>16 3 3</p></td>
        <td width="180"><p>56216160</p></td>
    </tr>
</table>
<p><strong>Решение:</strong><br>

<p>$W_{KXY}$ - количество программ для робота состоящих из $K$ инструкций, таких, что робот, выйдя из начала координат,
    придет в точку с координатами $(X, Y)$</p>

<p>$W_{0XY} = 0, X \ne 0, Y \ne 0$</p>

<p>$W_{000} = 1$ - в начальную клетку робот может попасть 1 способом.</p>

<p>Общий шаг: $W_{KXY} = W_{K-1,X-1,Y} + W_{K-1,X+1,Y} + W_{K-1,X,Y-1} + W_{K-1,X,Y+1}$</p>

<p>$Answer = W_{KXY}$</p>

<p><strong><cite>Взрывоопасность </cite></strong><br>
    При переработке радиоактивных материалов образуются отходы двух видов — особо опасные (тип A) и неопасные (тип B).
    Для
    их хранения используются одинаковые контейнеры. После помещения отходов в контейнеры, последние укладываются
    вертикальной стопкой. Стопка считается взрывоопасной, если в ней подряд идет более двух контейнеров типа A. Для
    заданного количества контейнеров N определить число безопасных стопок.<br>
    <cite>Входные данные:</cite><br>
    Одно число $1 \le N \le 30$.<br>
    <cite>Выходные данные:</cite> <br>
    Одно число — количество безопасных вариантов формирования стопки.</p>
<table border="1">
    <tr>
        <td width="170"><br>
            <strong>f.in</strong></td>
        <td width="180"><p><strong>f.out</strong></p></td>
    </tr>
    <tr>
        <td width="170"><p>5</p></td>
        <td width="180"><p>8</p></td>
    </tr>
</table>
<p><strong>Решение</strong><strong>:</strong></p>
<table border="0">
    <tr>
        <td width="319"><br>
            <img src="dynamic1/Info3.4.0_clip_image008_0000.gif" alt="" width="295" height="181"></td>
        <td width="169"><p><img src="dynamic1/Info3.4.0_clip_image010.gif" alt="" width="59" height="89">
        </p>
        </td>
        <td width="244"><p><img src="dynamic1/Info3.4.0_clip_image012.gif" alt="" width="166" height="89">
        </p>
        </td>
    </tr>
</table>
<p><strong style="text-decoration: underline;">К-ичные числа </strong><br>
    Требуется вычислить количество N-значных чисел в системе счисления с основанием K, таких, что их запись не содержит
    двух подряд идущих нулей. (2 \le K \le 10, N + K \le 18).<br>
    <cite>Входные данные:</cite><br>
    Числа N и K в десятичной записи, разделенные пробелом или переводом строки.<br>
    <cite>Выходные данные:</cite> <br>
    Искомое число в десятичной записи.</p>
<table border="1">
    <tr>
        <td width="170"><br>
            <strong>g.in</strong></td>
        <td width="180"><p><strong>g.out</strong></p></td>
    </tr>
    <tr>
        <td width="170"><p>4 3</p></td>
        <td width="180"><p>44 </p></td>
    </tr>
    <tr>
        <td width="170"><p>5 2</p></td>
        <td width="180"><p>8</p></td>
    </tr>
</table>
<p><strong>Решение</strong><strong>:</strong><br>
    <img src="dynamic1/Info3.4.0_clip_image014.gif" alt="" width="329" height="134"> <br>
    Для <img src="dynamic1/Info3.4.0_clip_image016.gif" alt="" width="33" height="11"> будет:<br>
    <img src="dynamic1/Info3.4.0_clip_image018.gif" alt="" width="78" height="64"> <br>
    Динамический переход:<br>
    <img src="dynamic1/Info3.4.0_clip_image020.gif" alt="" width="181" height="92"></p>

<p><strong><cite>Паровозики </cite></strong><br>
    N локомотивов, имеющих номера от 1 до N и установленных на железнодорожную колею, начинают двигаться в одну сторону,
    причем локомотив номер k изначально движется со скоростью k км/ч. Если локомотив, движущийся с большей скоростью,
    нагоняет более медленный локомотив, дальше они движутся один за другим со скоростью впереди идущего локомотива.
    Очевидно, через некоторое время после начала движения локомотивы разобьются на несколько групп, движущихся с разной
    скоростью.<br>
    Написать программу, определяющую, сколько начальных расстановок s из N! возможных дадут в результате p групп
    движущихся локомотивов.<br>
    <cite>Входные данные:</cite><br>
    Два числа — $1 \le N \le 16$ и $1 \le p \le N$.<br>
    <cite>Выходные данные:</cite> <br>
    Одно число — s.</p>
<table border="1">
    <tr>
        <td width="170"><br>
            <strong>h</strong><strong>.in</strong></td>
        <td width="180"><p><strong>h</strong><strong>.out</strong></p></td>
    </tr>
    <tr>
        <td width="170"><p>4 2</p></td>
        <td width="180"><p>11 </p></td>
    </tr>
    <tr>
        <td width="170"><p>5 4</p></td>
        <td width="180"><p>10</p></td>
    </tr>
    <tr>
        <td width="170"><p>6 6</p></td>
        <td width="180"><p>1</p></td>
    </tr>
</table>

<pre class="sh_pascal">
uses SysUtils;

const Nmax=16;

var
  Save : array [1..nmax,1..nmax,1..nmax] of Int64;

function F( i,n,p:byte; x:integer ):Int64;
{ i-ый паровоз впереди,
  n паровозов всего
  p групп }
var j:byte;
begin
  if Save[i,n,p]=-1 then begin
    if x=0 then writeln( Format('F(i=%d,n=%d,p=%d)=',[i,n,p] ) );
    Result := 0;
    { Рассмотрим, как может i-ый паровозик оказаться впереди }
    { При этом есть 2 варианта: }
    {  1. Он уйдёт вперёд и образует новую группу }
    {    Т.е. он быстрее предыдущего паровозика }
    {    Пусть предыдущий едет со скоростью j }
    { Мы могли получить это из ситуации:
       j in [1..i-1]
       n-1 паровоз всего;
       p-1 группа всего;
       т.е. новый паровоз образовал новую группу }
    for j:=1 to i-1 do begin
      Result := Result + F(j,n-1,p-1,x+1);
      if x = 0 then writeln( Format('  + F(i=%d,n=%d,p=%d)=%d',[j,n-1,p-1,F(j,n-1,p-1,x+1)] ) );
    end;
    {   i-ый не образует новую группу, т.е. j>i }
    for j:=i+1 to n do begin
      Result := Result + F(i,n-1,p,x+1);
      if x = 0 then writeln( Format('  + F(i=%d,n=%d,p=%d)=%d *',[i,n-1,p,F(i,n-1,p,x+1)] ) );
    end;
    Save[i,n,p] := Result;
  end;
  F:=Save[i,n,p];
  if (i>n) or (p>n) then
    assert( Result = 0 );
end;

var i,j,NN,PP,n,p:byte;
    s:Int64;
begin
  readln(NN,PP);
  for i:=1 to NN do
    for n:=1 to NN do
      for p:=1 to NN do begin
        Save[i,n,p]:=-1;
        if (i>n) or (p>n) then Save[i,n,p]:=0;
        { Одна группа - и не первый впереди - не может быть :) }
        if (p=1) and (i&lt;&gt;1) then Save[i,n,p]:=0;
        { Кол-во групп = кол-ву паровозов и первый - самый быстрый }
        if (n=p) and (i=n) then Save[i,n,p]:=1;
      end;
  for i:=1 to NN do
    for n:=1 to NN do
      for p:=1 to NN do begin
        if (n=p) and (i&lt;n) then assert( F(i,n,p,1) = 0 );
        if i&gt;n then assert( F(i,n,p,1) = 0,
          Format('F(%d,%d,%d)=%d',[i,n,p,F(i,n,p,1)]) );
      end;
  s:=0;
  for i:=1 to NN do
    s:=s+F(i,NN,PP,1);
  writeln(s);
end.
</pre>

</body>
</html>