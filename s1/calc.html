<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>Представление чисел в памяти и точность вычислений</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
    <script type="text/javascript" src="../syntax/sh_main.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_pascal.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_python.min.js"></script>
    <link type="text/css" rel="stylesheet" href="../style/sh_nedit.css">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});





    </script>
    <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>
<body onLoad="sh_highlightDocument();">
<div style="width:80%;">
    <div style="float:right;">
        <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
                codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0"
                width="100"
                height="50">
            <param name="movie" value="../audio/a_smsqulh3n.swf">
            <param name="bgcolor" value="fff">
            <param name="FlashVars" value="src=../audio/6016574696f60301------------ffffff">
            <param name="autoplay" value="false">
            <embed src="../audio/a_smsqulh3n.swf" bgcolor="fff" width="100" height="70"
                   type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer"
                   FlashVars="src=../audio/6016574696f60301------------ffffff"></embed>
        </object>
    </div>
</div>

<div id="content">
    <h1>Представление чисел в памяти и точность вычислений</h1>

    <ul class="tags">
        <li><a href="#">Представление чисел</a></li>
        <li><a href="#">Точность</a></li>
    </ul>

    <h2>Представление целых чисел в памяти компьютера</h2>

    <p>Микропроцессор рассчитан на определённую разрядность поступающих в него данных, у процессора определённое
        ограниченное количество ножек, каждая ножка отвечает за определённый двоичный разряд числа. Например, если
        процессор является 32-битным, то основной размер числа для него 32 бита, т.е. число размером 32 бита (4 байта)
        может быть передано в память или из памяти за один такт (один цикл обработки данных процессором).
    </p>

    <p>Наиболее эффективным по скорости является использование "родной" для этого процессора разрядности: если процессор
        16-битный, то это 16 бит, если 32-битный, то 32 бита. Если число больше по размеру (например: 40 бит для
        32-битного процессора), то процессор будет его обрабатывать уже (минимум) в два прохода.
        Если число будет меньше чем 32 бита, то процессор всё равно не сможет обработать несколько чисел за такт, а если
        потребуется сложить или вычесть два числа с разной разрядностью, то потребуется ещё и привести их к разрядности
        большего числа. Так что самое выгодное с точки зрения скорости - использовать для всех целых чисел тип данных с
        &quot;родной&quot; для процессора разрядностью (например, при программированни на Delphi для 32-битных
        процессоров использовать тип Integer). С точки зрения экономии памяти выгодно использовать как можно меньше байт
        памяти (типы как можно меньшего размера).</p>

    <p>Какие же числа можно представить в 8 битах? В одном бите можно представить только 2 значения: 0 или 1. В двух
        битах – 4 значения: 00, 01, 10, 11. В $N$ битах можно представить $2^N$ различных значений.
        Для целых неотрицательных чисел логично считать, что когда все разряды 0, то это число 0, а когда все разряды 1,
        то это максимальное число, которое в этом случае равно $2^N-1$.</p>

    <p>Если число не укладывается ни в один из стандартных типов, то надо реализовывать <a href="long_ar.html">"Длинную
        арифметику" (ссылка на урок по "Длинной арифметике")</a>.</p>

    <h2>Целые числа и дополнительный код</h2>

    <p><strong>Дополнительный код </strong>- самый распространённый способ представления отрицательных целых чисел в
        компьютерах. Он позволяет заменить операцию вычитания на операцию сложения (используя свойства переполнения) и
        сделать операции сложения и вычитания одинаковыми для знаковых и беззнаковых чисел, чем упрощает архитектуру
        ЭВМ.
        Дополнительный код отрицательного числа можно получить инвертированием модуля двоичного числа (первое
        дополнение) и
        прибавлением к инверсии единицы (второе дополнение). Либо вычитанием числа из нуля. </p>

    <p>Примеры:</p>
    <ul>
        <li>1 =&gt; 00000001</li>
        <li>0 =&gt; 00000000</li>
        <li>-1 =&gt; 11111111</li>
    </ul>
    <h2>Инструмент исследования представления чисел в памяти</h2>

    <p>Для того чтобы исследовать формат представления переменных различных типов в памяти можно использовать следующий
        приём: создать указатель на массив байт и сделать, чтобы он ссылался на нужную нам исследуемую переменную и
        вывести
        побайтно содержимое памяти (столько байт, сколько занимает эта переменная).</p>
<pre class="sh_pascal">
{ Массив для вывода шестнадцатеричных цифр }
const Hex : array [0..15] of Char =
  ('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');

var
  X : Integer; { X - исследуемая переменная, Integer - исследуемый тип (замените на интересующий) }
  P : array of Byte = @X; { P - указатель на массив байт, который указывает на переменную X }
  i,j : Integer; { Переменные циклов }
begin
  { Считываем исходное значение }
  Readln(X);
  { Вывод в двоичной системе счисления }
  for i := sizeof(x) - 1 downto 0 do begin { Цикл по байтам (начиная со старшего) }
    for j := 7 downto 0 do { Цикл по битам (начиная со старшего) }
      write((P[i] shr j) and 1); { Получаем бит j: сдвигаем на j-бит вправо и берём последний бит }
    if i > 0 then write(' '); { Между байтами выводим пробел }
  end;
  writeln;
  { Вывод в шестнадцатеричной системе счисления }
  for i := sizeof(x) - 1 downto 0 do begin
    { Вывод 2-х шестнадцатеричных цифр - содержимое i-ого байта }
    write(Hex[P[i] div 16], Hex[P[i] mod 16]);
    if i > 0 then write(' ');
  end;
  writeln;
end.</pre>

    <p>Вместо массива шестнадцатеричных символов можно использовать функцию (в ней труднее ошибиться):</p>

<pre class="sh_pascal">
procedure out_hex_digit(b: Byte);
begin
  if b < 10 then write(chr(b + ord('0')))
            else write(chr(b + ord('A') - 10));
end;</pre>

    <p>В этом примере были использованы побитные операции:</p>
    <ul>
        <li>A <strong>shr</strong> B - сдвиг числа A вправо на B бит (младшие биты при этом теряются).</li>
        <li>A <strong>and</strong> B - побитная операция &quot;И&quot; в C := A and B бит будет установлен в 1, только
            если он 1 и в A и B.
        </li>
    </ul>
    <p>Теперь, когда у нас есть программа для проведения экспериментов, мы можем изучить как представляются различные
        типы данных в памяти.</p>

    <h2>Неточность представления чисел с плавающей запятой</h2>

    <p>Как хранить нецелые числа в компьютере? Вариантов много. Можно, например, хранить их в виде рациональных дробей
        (тогда мы можем использовать механизм хранения целых чисел).</p>

    <p>Любые типы данных в компьютере хранятся как последовательность бит.
        Для записи действительных чисел хранится порядок и мантисса. Т.е. число хранится как двоичная дробь.
        Вначале стоит точка, затем мантисса, а затем порядок (двоичная степень).</p>

    <p>Любое действительное число не кратное 2 хранится неточно. С погрешностью в последнем бите мантиссы.
        Задача про сравнение это наглядно показывает.</p>

    <p>&nbsp;</p>
<pre class="sh_pascal">
uses SysUtils;
var a,b,c:extended;
begin
  reset(input,'eq.in');
  rewrite(output,'eq.out');
  readln(a,b,c);
  if (abs(a+b-c) < 0.0000001) then writeln('YES') else writeln('NO');
end.</pre>

    <h2>Эксперимент на Delphi на точность сравнения</h2>

<pre class="sh_pascal">{$APPTYPE CONSOLE}

{ Сравнение без учёта погрешности машинного представления чисел }
function eq1(a,b,c:extended):boolean;
begin
  result := a+b = c;
end;

{ С учётом погрешности }
function eq2(a,b,c:extended):boolean;
begin
  result := abs(a+b-c) < 1e-17;
end;

var a,b,c : extended;
begin
  a := 0.1;
  b := 1.2;
  c := 1.3;
  writeln(a+b=c); // FALSE
  writeln(0.1+1.2=1.3); // TRUE, хотя написано, вроде бы, то же самое
  writeln(0.1+0.1+0.1-0.3=0.0); // TRUE
  writeln(1+0.1-1=0.1); // FALSE, как ни странно :)
end.
</pre>


    <p>Для предоления проблем с точностью вычислений в языке программирования Python есть специальный тип Decimal, этот
        тип основан на модели чисел с плавающей точкой, которая разработана по принципу: &quot;компьютер должен
        обеспечивать арифметические действия, которые работают так же, как людей обучают в школе&quot;.</p>

    <p>Например: 0.1+0.1+0.1-0.3 в точности равно 0.</p>

<pre class="sh_python">
from decimal import *
</pre>

    <h2>Действительные числа (с плавающей точкой, floating point)</h2>

    <p>Задачки с трудностями с точностью результата бывают на олимпиадах любого уровня. Запоминать битовое представление
        чисел - необязательно, но знать что могут быть проблемы с точностью и как их решать - нужно.</p>
    
    
<pre class="sh_pascal">
{$apptype console}
function convert(x : extended) : int64;
begin
  result := trunc(x);
  assert(abs(result) &lt; int64(1) * 1000000 * 
                                  1000000 * 
                                  1000000);
end;
var a, b : extended;
begin
  a := -706378499182879656;
  b := -513623273852583522;
  writeln((a+b):0:0);
  writeln(convert(a) + convert(b));
end.
</pre>
</div>

</body>

</html>