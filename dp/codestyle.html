<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>Стиль оформления кода программы</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
    <script type="text/javascript" src="../syntax/sh_main.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_xml.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_cpp.min.js"></script>
    <link type="text/css" rel="stylesheet" href="../style/sh_nedit.css">
</head>
<body onLoad="sh_highlightDocument()">
<div id="content">
<h1>Стиль оформления кода программы</h1>

<h3>Отступы, &quot;лесенка&quot;, пробелы</h3>

<p><strong>Зачем?</strong></p>

<p>Одним из важнейших факторов, влияющих на способность программы к развитию, является лёгкость её
    <strong>понимания</strong>. Одним из существенных факторов понимаемости программы, в свою очередь, является
    информативность исходного текста. Если исходный текст не является хорошо читаемым, то есть написан без соблюдения
    определенного стиля и системы и представляет собой &quot;мешанину&quot; операторов и знаков препинания, то вносить
    изменения в него очень сложно даже автору. Рассмотрим ряд требований и рекомендаций, позволяющих выработать хороший
    стиль оформления программ, повышающий ее информативность.</p>

<p><strong><em>Лесенка в 4 пробела</em></strong></p>

<p>Обязательна «лесенка» с отступом в 4 пробела. При этом запрещается в редакторе изменять
    размер&nbsp;<em>отображаемой</em>&nbsp;табуляции, например, выставлять отображение табуляции в 4 пробела. Код,
    созданный Вами при таких настройках, будет некорректно отображаться в других редакторах с другими настройками.</p>

<p><strong><em>Пробелы после запятых</em></strong></p>

<p>Ставятся после запятых и точек с запятой (если, конечно, они не расположены в конце строки). Перед запятой и точкой с
    запятой пробелы не ставятся:</p>
<pre class="sh_cpp">    
  a = (1, 2, 3);
  for(int i = 0; i &lt; count; i++) {  };
</pre>

<h2><em>Пробелы вокруг знаков операций</em></h2>

<p>Любые операторы / знаки операций ( например &quot;=&quot;, &quot;==&quot;, &quot;=&gt;&quot;, &quot;&lt;&quot;,
    &quot;&gt;&quot;, &quot;&amp;&amp;&quot;, &quot;||&quot; и т.п.) отделяются пробелами с обеих сторон:</p>
<table border="1" cellspacing="0" cellpadding="0" align="left">
    <tr>
        <td width="386" valign="top"><p>a = b * c + d * e; <br>
            a = b * c  +  d * e; </p></td>
    </tr>
</table>
<p> </p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h2><em>Пробелы вокруг сложных индексных выражений</em></h2>

<p>В случае, если Вы обращаетесь к элементу массива  по индексу и индексное выражение достаточно сложное, отделяйте его
    пробелами для улучшения удобочитаемости. Если выражение простое — пробелы не обязательны.</p>
<table border="1" cellspacing="0" cellpadding="0" align="left">
    <tr>
        <td width="403" valign="top"><br>
            a[1];<br>
            a[1 + 2 + 2 + 4];
        </td>
    </tr>
</table>
<p>&nbsp;</p>

<h2>&nbsp;</h2>

<h2><em>Пробел перед открывающей фигурной скобкой</em></h2>
<table border="1" cellspacing="0" cellpadding="0" align="left">
    <tr>
        <td width="323" valign="top"><p>if (condition) {<br>
            statement;<br>
            } </p></td>
    </tr>
</table>
<p> Перед открывающей фигурной скобкой в блочных конструкциях ставится пробел:<br>
</p>

<h2>&nbsp;</h2>

<h2><em>Пробелы после знака комментария</em></h2>

<p>После символа начала комментария («//») перед текстом самого комментария ставится пробел.</p>
<table border="1" cellspacing="0" cellpadding="0" align="left">
    <tr>
        <td width="170" valign="top"><br>
            // INIT
        </td>
    </tr>
</table>
<p>&nbsp;</p>

<h2>&nbsp;</h2>

<h2><em>Максимальная длина строк</em></h2>

<p>Строки желательно не оставлять слишком длинными; условное ограничение —          80-100-120 символов в строке. При
    необходимости строка разбивается на несколько.<br>
</p>
<table border="1" cellspacing="0" cellpadding="0" width="371">
    <tr>
        <td width="371" valign="top"><br>
            very_long_statement<br>
            if condition;<br>
            if (<br>
            very_long_condition_1<br>
            &amp;&amp; very_long_condition_2<br>
            ) {<br>
            statement;<br>
            }
            <p>if (<br>
                ..<br>
                &amp;&amp;<br>
                ...<br>
                ||<br>
                ...<br>
                ) {<br>
                ...<br>
                }</p></td>
    </tr>
</table>
<h2><em>Открывающая фигурная скобка на той же строке, что и ключевое слово</em></h2>

<p>Старайтесь придерживаться компактного  стиля оформления циклов и блоков ветвления: открывающая фигурная скобка
    находится на той же строке, что и ключевое слово &quot;for&quot;, &quot;if&quot;, &quot;else&quot;, &quot;while&quot;
    и т.п.<br>
    Закрывающая фигурная скобка блока, состоящего из нескольких строк, должна находиться на одной вертикали с ключевым
    словом начинающим конструкцию.<br>
</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tr>
        <td width="351" valign="top"><br>
            if (condition) {<br>
            statement1;<br>
            }<br>
            else {<br>
            statement2;<br>
            }<br>
            for (int i = 0; i &lt; $count; i++ ) {<br>
            statement;<br>
            }
        </td>
    </tr>
</table>
<p>&nbsp;</p>

<h2><em>Допускается компактное оформление блоков из одного оператора</em></h2>

<p>Однострочные блоки, состоящие из единственного оператора, могут быть помещены в одну строку вместе с открывающими и
    закрывающими скобками:</p>
<table border="1" cellspacing="0" cellpadding="0" width="484">
    <tr>
        <td width="484" valign="top"><br>
            for (int i = 0; i &lt; count; i++ ) { summ += i; };
        </td>
    </tr>
</table>
<h2><em>Разбивайте код на абзацы, при необходимости снабжённые комментариями</em></h2>

<p>Код внутри функций должен быть разделён на смысловые блоки, выполняющие определённую узкую задачу. Смысловые блоки
    отделяются друг от друга пустыми строками. Для дальнейшего улучшения читаемости кода, добавляйте вначале каждого
    абзаца однострочный комментарий, объясняющий, что делает эта последовательность операторов.</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tr>
        <td width="616" valign="top"><br>
            addarray_internal {<br>
            string (string var_name, string needs_quotemeta) ;
            <p>    // Запомнить оригинал...<br>
                raw = var_name;</p>

            <p>    // Добавить экранирование спецсимволов, если необходимо...<br>
                string quotemeta = needs_quotemeta ?  q{map {quotemeta $_} } ;</p>

            <p>    # Перевести элементы переменной в строку, соединяя их с помощью &quot;|&quot;...<br>
                my $perl5pat = qq{(??{join q{|}, $quotemeta \@{$var_name}})};</p>

            <p>    # Добавить отладочный код, если необходимо...<br>
                my $type = $quotemeta ? 'literal' : 'pattern';<br>
                debug_now(&quot;Adding $var_name (as $type)&quot;);<br>
                add_debug_mesg(&quot;Trying $var_name (as $type)&quot;);<br>
                return $perl5pat;<br>
                }</p></td>
    </tr>
</table>
<p>&nbsp;</p>

<h2><em>Не отделяйте имена переменных и функций от следующей за ними открывающей скобки</em></h2>

<p>Важно ставить открывающую скобку слитно с именем функции или переменной. В противном случае можно визуально спутать
    функцию с ключевым словом, а начало выражения для элемента массива или хэша со скаляром.</p>
<table border="1" cellspacing="0" cellpadding="0" width="621">
    <tr>
        <td width="621" valign="top"><br>
            # ХОРОШО <br>
            next CANDIDATE if open_region($i);
            <p>$candidates[$i] = $incumbent{ $candidates[$i]{region} };</p></td>
    </tr>
</table>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tr>
        <td width="616" valign="top"><p># ПЛОХО!<br>
            next CANDIDATE if open_region  ($i);</p>

            <p>$candidates[$i] = $incumbent   { $candidates[$i]{region} };</p></td>
    </tr>
</table>
<p>&nbsp;</p>

<h2><em>Осмысленные названия идентификаторов</em></h2>

<p>Выбирайте осмысленные названия для идентификаторов (переменных, констант, функций). Исключение составляют итераторы
    циклов, где допускаются короткие идентификаторы: ib, n и т.п</p>
<ul>
    <li><strong><em>Одна функция выполняет одну задачу</em></strong></li>
</ul>
<p>Если функция выполняет несколько разных, слабо связанных друг с другом задач, подумайте о том, чтобы разбить эту
    функцию на несколько. И наименования функций по возможности должны представлять из себя глагол, например
    get_domain_name, или chash_my_program.</p>

<h2><em>Отступы и комментарии для функций</em></h2>

<p>Функции отделены друг от друга минимум одной пустой строкой. Для каждой функции необходимо краткое однострочное
    описание того, что она делает:</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tr>
        <td width="616" valign="top"><br>
            # Получить имя домена по его id<br>
            sub get_domain_name {<br>
            ...<br>
            }
        </td>
    </tr>
</table>
<p>&nbsp;</p>

<h2><em>Наименование моделей в стиле MyModuleName</em></h2>

<p>Модули  следует называть в стиле MyModuleName, т.е. слова склеиваются между собой, каждое слово записывается с
    заглавной буквы.  Последняя строка кода модуля обязательно заканчивается переносом строки.</p>

<h2><em>Комментарий вначале модуля</em></h2>

<p>Вначале модуля желателен комментарий, описывающий назначение модуля.</p>

<h2><em>Сокращённая форма записи, основанная на ||</em></h2>

<p>Приветствуется использование сокращённой формы записи, основанной на применении логического оператора &quot;или&quot;. </p>
<table border="1" cellspacing="0" cellpadding="0" width="620">
    <tr>
        <td width="620" valign="top"><br>
            $a = $b || $c<br>
            лучше, чем<br>
            $a = $b ? $b : $c<br>
            и тем более лучше, чем<br>
            if ($b) {<br>
            $a = $b;<br>
            }<br>
            else {<br>
            $a = $c;<br>
            }<br>
            Также <br>
            $a ||= $b<br>
            лучше, чем <br>
            $a = $b unless $a;
        </td>
    </tr>
</table>
<p>&nbsp;</p>

<h2><em>Используйте and и or вместо условных конструкций if</em></h2>

<p>В ряде случаях (когда при каком либо условии нужно выполнить всего один оператор) удобнее выполнять условный код с
    помощью and или or, чем громоздить блоки if:</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tr>
        <td width="616" valign="top"><br>
            imp back  or die &quot;can't imp back!&quot;;<br>
            $username = get_user_name() and print &quot;Username: $username\n&quot;;
        </td>
    </tr>
</table>
<p>&nbsp;</p>
<ul>
    <li><strong><em>Минимизация использования циклов&nbsp;for&nbsp;и обращений к элементам по индексу</em></strong></li>
</ul>
<p>Старайтесь избегать использование классического цикла&nbsp;for&nbsp;с целочисленным индексом, везде, где это
    возможно. При обработке элементов списка отдавайте предпочтение циклам foreach, а также функциям, обрабатывающим
    сразу весь список сразу, таким как&nbsp;grep,&nbsp;map,&nbsp;sort,&nbsp;join,&nbsp;splitи т.д.</p>

<h3><em>Преимущества и недостатки использования утилит для автоматического форматирования исходного текста
    программы.</em></h3>

<p>Преимущества:</p>
<ul>
    <li>Выполняется форматирование и подсветка кода ;</li>
    <li>В некоторых программах присутствует, как гибкий инструмент, который может быть сильно изменен пользователем, как
        в плане интерфейса, так и функциональности, чтобы лучше подходить его личным задачам и предпочтениям.
    </li>
</ul>
<p>Недостатки:</p>
<ul type="disc">
    <li>Редакторы приходится регулярно запускать;</li>
    <li>Иногда присутствуют проблемы с буфером обмена. Русские символы, скопированные в буфер из редактора, превратятся
        в «крякозябры»;
    </li>
    <li>невысокая скорость работы и требовательность к ресурсам системы.</li>
</ul>
<h3>Преимущества и недостатки использования утилит для автоматического форматирования исходного текста
    программы</h3>

<b>Преимущества:</b>

<ol>
    <li>Один раз настраиваем правила и дальше весь проект всегда отформатирован в одном стиле.</li>
</ol>

<b>Недостатки:</b>

<ol>
    <li>Утититы форматирования надо регулярно запускать (или автоматизировать их запуск).</li>
    <li>Во многих случаях при форматировании "вручную" можно лучше отразить структуру программы или данных.</li>
</ol>
<h3>Список литературы:</h3>

<ul>
    <li>Макконел - Совершенный код</li>
</ul>

</div>
</body>
</html>
