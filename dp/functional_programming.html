<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>Функциональное программирование (LISP). Логическое программирование (Prolog)</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
    <script type="text/javascript" src="../syntax/sh_main.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_prolog.min.js"></script>
    <style type="text/css"></style>
</head>
<body>
<div id="content">
    <h1>Функциональное программирование (LISP). Логическое программирование (Prolog)</h1>

    <p><strong>Функциональное программирование</strong> - раздел дискретной математики и парадигма программирования, в
        которой процесс вычисления трактуется как вычисление значений функций в математическом понимании (в отличие от
        функций как подпрограмм в процедурном программировании). У функции в математике есть аргументы и результат, она
        не меняет состояние остальной программы (отсутствуют побочные эффекты).</p>

    <p>Противопоставляется парадигме <strong>императивного</strong> программирования, которая описывает процесс
        вычислений как последовательное изменение состояний (как в теории автоматов). </p>

    <p>Функциональное программирование предлагает обходиться вычислением результатов функций от исходных данных и
        результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не
        предполагает оно и изменяемость этого состояния (в отличие от императивного, где одной из базовых концепций
        является <strong>переменная</strong>, <em>хранящая</em> своё значение и позволяющая <em>менять</em> его по мере
        выполнения алгоритма). </p>


    <p>&nbsp;</p>

    <p>Сформулированная Джоном Мак-Карти (1958) концепция символьной обработки информации компьютером восходит к
        идеям <a href="http://ru.wikipedia.org/wiki/%D0%A7%D1%91%D1%80%D1%87,_%D0%90%D0%BB%D0%BE%D0%BD%D0%B7%D0%BE"
                 title="Чёрч, Алонзо">Черча</a> и других математиков, известным как <a
                href="http://ru.wikipedia.org/wiki/%D0%9B%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5"
                title="Лямбда-исчисление">лямбда-исчисление</a> с конца 20-х годов XX века. </p>

    <p>Выбирая лямбда-исчисление как теоретическую модель, Мак-Карти предложил рассматривать функции как общее базовое
        понятие, к которому достаточно естественно могут быть сведены все другие понятия, возникающие при
        программировании. </p>

    <p>Существуют различия в понимании <a
            href="http://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)"
            title="Функция (математика)">функции в математике</a> и <a
            href="http://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Функция (программирование)">функции в программировании</a>, вследствие чего нельзя отнести <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)"
            title="Си (язык программирования)">Си</a>-подобные языки к функциональным, использующим менее строгое
        понятие. Функция в математике не может изменить вызывающее её окружение и запомнить результаты своей работы, а
        только предоставляет результат вычисления функции.</p>

    <p>Программирование с использованием математического понятия функции вызывает некоторые трудности, поэтому
        функциональные языки, в той или иной степени предоставляют и императивные возможности, что ухудшает дизайн
        программы (например возможность безболезненных дальнейших изменений). </p>

    <p>Дополнительное отличие от <a
            href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Процедурное программирование">императивных языков программирования</a> заключается в декларативности
        описаний функций. Тексты программ на функциональных языках программирования <em>описывают</em> «как решить
        задачу», но не <em>предписывают</em> последовательность действий для решения. </p>

    <p>Первым функциональным языком стал <a href="http://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF" title="Лисп">Лисп</a>.
        Он был предложен Джоном Мак-Карти в качестве средства исследования границ применимости компьютеров, в частности,
        методом решения задач искусственного интеллекта. </p>

    <p> Вариант данного языка широко используется в системе автоматизированного проектирования <a
            href="http://ru.wikipedia.org/wiki/AutoCAD" title="AutoCAD">AutoCAD</a> и называется <a
            href="http://ru.wikipedia.org/wiki/AutoLISP" title="AutoLISP">AutoLISP</a></p>

    <p>Основные преимущества функциональных языков:</p>

    <h3><strong>Краткость и простота</strong>
    </h3>

    <p>Программы на функциональных языках обычно намного короче и проще, чем те же самые программы на императивных
        языках.<br>
        <em>Пример (быстрая сортировка Хоара на абстрактном функциональном языке)</em>:</p>
<pre>quickSort ([]) = []<br>quickSort ([h : t]) = quickSort (n | n   t, n &lt;= h) + [h] + quickSort (n | n   t, n &gt; h)  
</pre>
    <h3><strong> Строгая типизация</strong></h3>

    <p>В функциональных языках большая часть ошибок может быть исправлена на стадии компиляции, поэтому стадия отладки и
        общее время разработки программ сокращаются. Вдобавок к этому строгая типизация позволяет компилятору
        генерировать более эффективный код и тем самым ускорять выполнение программ.</p>

    <p><strong>Модульность</strong></p>

    <p>Механизм модульности позволяет разделять программы на несколько сравнительно независимых частей (модулей) с чётко
        определёнными связями между ними. Тем самым облегчается процесс проектирования и последующей поддержки больших
        программных систем. Поддержка модульности не является свойством именно функциональных языков программирования,
        однако поддерживается большинством таких языков.</p>

    <p><strong>Функции - объекты вычисления</strong></p>

    <p>В функциональных языках (равно как и вообще в языках программирования и математике) функции могут быть переданы
        другим функциям в качестве аргумента или возвращены в качестве результата. Функции, принимающие функциональные
        аргументы, называются функциями высших порядков или функционалами.</p>

    <h3>Чистота (нет побочных эффектов)</h3>

    <p>В чистом функциональном программировании оператор присваивания отсутствует, объекты нельзя изменять и уничтожать,
        можно только создавать новые путем декомпозиции и синтеза существующих. О ненужных объектах позаботится
        встроенный в язык сборщик мусора. Благодаря этому в чистых функциональных языках все функции свободны от
        побочных эффектов.</p>

    <h3><strong>Отложенные (ленивые) вычисления</strong></h3>

    <p>В императивных языках программирования (например, C++) вызов функции приводит к вычислению всех аргументов. Этот
        метод вызова функции называется <strong>вызов-по-значению</strong>. Если какой-либо аргумент не использовался в
        функции, то результат вычислений пропадает, следовательно, вычисления были произведены впустую.
        Противоположностью <strong>вызова-по-значению</strong> является <strong>вызов-по-необходимости</strong> (ленивые
        вычисления). В этом случае аргумент вычисляется, только если он нужен для вычисления результата.</p>

    <h2>LISP</h2>

    <p>Тексты программ на функциональных языках программирования <em>описывают</em> «как решить задачу», но не <em>предписывают</em> последовательность
        действий для решения. </p>

    <p>Первым спроектированным функциональным языком стал <a
            href="http://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF" title="Лисп">Лисп</a>. </p>

    <p><strong>Лисп</strong> <strong>/ LISP</strong> (<em><span lang="en"
                                                                xml:lang="en"><strong>LIS</strong>t <strong>P</strong>rocessing language</span></em> -
        «язык обработки списков») -  семейство ЯП, программы и данные в которых представляются системой вложенных
        списков.</p>

    <p>Лисп является вторым в истории (после Фортрана) используемым по сей день высокоуровневым языком
        программирования. </p>

    <p><a href="http://ru.wikipedia.org/wiki/Лисп">http://ru.wikipedia.org/wiki/Лисп</a></p>

    <h2>Haskell</h2>

    <p><strong>Haskell (Хаскель, Хаскелл)</strong> - стандартизованный чистый функциональный ЯП общего назначения (один
        из самых распространённых с поддержкой отложенных/ленивых вычислений). Типизация строгая, статическая, с
        автоматическим выводом типов. </p>

    <p>Концепция языка отражает идею математика Хаскелла Карри, писавшего, что «доказательство — это программа, а
        доказываемая формула — это тип программы». Именно в честь Х. Карри язык и получил своё название. </p>

    <h2>Логическое программирование - Prolog</h2>

    <p><strong>Пролог</strong> (фр. <strong>Pro</strong>grammation en <strong>Log</strong>ique) - язык и система
        логического программирования, основанные на языке предикатов математической логики дизъюнктов Хорна,
        представляющей собой подмножество логики предикатов первого порядка.

    </p>

    <p>Основными понятиями в языке Пролог являются факты, правила логического вывода и запросы, позволяющие описывать
        базы знаний, процедуры логического вывода и принятия решений.

    </p>

    <p><strong>Факты</strong> в языке Пролог описываются логическими предикатами с конкретными значениями. </p>

    <p><strong>Правила</strong> в Прологе записываются в форме правил логического вывода с логическими заключениями и
        списком логических условий. </p>

    <p>Особую роль в интерпретаторе Пролога играют конкретные запросы к базам знаний, на которые система логического
        программирования генерирует ответы «истина» и «ложь». Для обобщённых запросов с переменными в качестве
        аргументов созданная система Пролог выводит конкретные данные в подтверждение истинности обобщённых сведений и
        правил вывода. </p>

    <p>Факты в базах знаний на языке Пролог представляют конкретные сведения (знания). </p>

    <p>Обобщённые сведения и знания в языке Пролог задаются правилами логического вывода (определениями) и наборами
        таких правил вывода (определений) над конкретными фактами и обобщёнными сведениями.

    </p>

    <p>Начало истории языка относится к 1970-м годам. </p>

    <p>Будучи декларативным языком программирования, Пролог воспринимает в качестве программы некоторое описание задачи
        или баз знаний и сам производит логический вывод, а также поиск решения задач, пользуясь механизмом поиска с
        возвратом и унификацией.

    </p>

    <p>Пролог критикуется в первую очередь за неполную декларативную природу. Создание программ в полностью
        декларативном стиле практически невозможно, требуется прибегать к процедурным приёмам, что приводит к резкому
        возрастанию сложности создания и отладки программ, а также плохой контролируемости промежуточных
        результатов. </p>

    <p>Другим часто подвергаемым критике свойством языка является отсутствие типизации. В языке предопределён порядок
        обхода дерева решений в глубину и стандартизированы операторы, позволяющие вмешиваться в этот процесс (такие как
        оператор отсечения ! или ветвления ->) и не позволяющие распараллелить программу, задействовав в поиске решения
        несколько процессоров или узлов сети.</p></div>
</body>
</html>
