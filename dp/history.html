<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>История развития языков программирования</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
</head>
<body>
<div id="content">
<h1>История развития языков программирования</h1>

<p><strong>1837</strong> - Коды операций аналитической машины Чарльз Бэббидж и Ада Лавлэйс.</p>

<p>Первые программы заключались в установке ключевых переключателей на передней панели вычислительного
    устройства. Очевидно, таким способом можно было составить только небольшие программы.</p>

<strong>Появление машинного языка</strong>

<p>С развитием компьютерной техники появился машинный язык, с помощью которого программист мог задавать
    команды, оперируя с ячейками памяти, полностью используя возможности машины. Однако использование
    большинства компьютеров на уровне машинного языка затруднительно, особенно это касается ввода-вывода.
    Поэтому от его использования пришлось отказаться.</p>

<p>«Слова» на машинном языке - <strong>инструкции</strong>, каждая из которых представляет собой одно элементарное
    действие для центрального процессора, такое, например, как считывание информации из ячейки памяти. </p>

<p>Каждая модель процессора имеет свой собственный набор машинных команд, хотя большинство из них совпадает.
    Если Процессор А полностью понимает язык Процессора Б, то говорится, что Процессор А совместим с Процессором
    Б. Процессор Б будет называться не совместимым с Процессором А если А имеет команды, не распознаваемые
    Процессором Б.</p>

<p>На протяжении 60-х годов запросы на разработку программного обеспечения возросли и программы стали очень
    большими. Люди начали понимать, что создание программного обеспечения — гораздо более сложная задача, чем
    они себе представляли. Это привело к тому, что было разработано структурное программирование. С развитием
    структурного программирования следующим достижением были процедуры и функции. К примеру, если есть задача,
    которая выполняется несколько раз, то её можно объявить как функцию или процедуру и в выполнении программы
    просто вызывать её. Общий код программы в данном случае становится меньше. Функции позволяют создавать
    модульные программы.</p>

<p>Следующим достижением было использование структур, благодаря которым перешли к классам. Структуры — это
    составные типы данных, построенные с использованием других типов. Например, структура время. В неё входит:
    часы, минуты, секунды. Программист мог создать структуру время и работать с ней, как с отдельной структурой.
    Класс — это структура, которая имеет свои переменные и функции, которые работают с этими переменными. Это
    было очень большое достижение в области программирования. Теперь программирование можно было разбить на
    классы и тестировать не всю программу, состоящую из 10’000 строк кода, а разбить программу на 100 классов, и
    тестировать каждый класс. Это существенно облегчило написание программного продукта.</p>

<p><strong>Вехи в истории развития языков программирования:</strong></p>

<p><strong>Fortran</strong> (1954-57) - первый язык программирования высокого уровня, имеющий транслятор. Обеспечивал
    представление формул в естественной для математиков форме.
    Название Fortran является сокращением от <strong>FORmula TRANslator</strong> (переводчик формул). </p>

<p><strong>Algol</strong> (1958-1960) - структурное программирование (для выражения алгоритмов и структур данных). Отказ
    от GOTO
    и уход от глобальных переменных.</p>

<p><strong>Pascal</strong> (1970) - Algol для учебных целей. Автор - <a
        href="http://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82,_%D0%9D%D0%B8%D0%BA%D0%BB%D0%B0%D1%83%D1%81"
        title="Вирт, Никлаус">Никлаус Вирт</a>. Первая публикация Вирта о языке датирована 1970 годом, представляя язык,
    автор указывал в качестве цели его создания - построение небольшого и эффективного языка, способствующего хорошему
    стилю программирования, использующему структурное программирование и структурированные данные.</p>

<p><strong>C</strong> (1969-73) - системное программирование на языке высокого уровня. Разработан в 1969-73 годах
    сотрудниками Bell Labs Кеном Томпсоном и Деннисом Ритчи как развитие языка B. Первоначально был разработан для
    реализации операционной системы UNIX, но, впоследствии, был перенесён на множество других платформ. Благодаря
    близости по скорости выполнения программ, написанных на C, к языку ассемблера, этот язык получил широкое применение
    при создании системного программного обеспечения и прикладного программного обеспечения для решения широкого круга
    задач. Язык программирования C оказал существенное влияние на развитие индустрии программного обеспечения, а его
    синтаксис стал основой для таких языков программирования как C++, C#, Java и D.</p>

<h2>Объектно-ориентированное программирование (ООП)</h2>

<p><strong>Симула</strong> (1967) - язык программирования общего назначения, разработанный в конце 60-х сотрудниками
    Норвежского Вычислительного Центра (Осло) Кристеном Нюгордом и Оле-Йоханом Далем для моделирования сложных систем.
    Симула считается первым в мире объектно-ориентированным языком, хотя создатель языка Smalltalk Алан Кэй утверждает,
    что изобрёл термин «ООП» и не вдохновлялся Симулой и С++.</p>

<p><strong>SmallTalk</strong> - объектно-ориентированный язык программирования с динамической типизацией,
    разработанный в Xerox PARC Аланом Кэйем, Дэном Ингаллсом, Тедом Кэглером, Адель Голдберг, и другими в 1970-х годах.
    ООП было добавлено в Pascal - Object Pascal, Delphi, и в C - C++, Objective C. </p>

<p>Но с развитием компьютерной техники появился <a
        href="http://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA"
        title="Машинный язык">машинный язык</a>, с помощью которого <a
        href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82"
        title="Программист">программист</a> мог задавать команды, оперируя с ячейками памяти, полностью используя
    возможности машины. Суть этого языка&nbsp;— набор кодов, обязательно понятных процессору, к кому обращаются.
    Части («слова») этого языка называются <a
            href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8"
            title="Код операции"><em>инструкциями</em></a>, каждая из которых представляет собой одно элементарное
    действие для центрального процессора, как, например, считывание информации из ячейки памяти. Если знаешь, можно
    непосредственно управлять процессором. Тогда ещё компьютеры были простыми вычислительными машинами, основная
    задача была считать. Но они развивались, а, понятно дело, использование большинства компьютеров на уровне
    машинного языка затруднительно, особенно это касается ввода-вывода. Поэтому со временем от его использования
    пришлось отказаться.<br>
    Например, для организации чтения блока данных с гибкого диска программист может использовать 16 различных
    команд, каждая из которых требует 13 параметров, таких как номер блока на диске, номер сектора на дорожке и&nbsp;т.&nbsp;п.
    Когда выполнение операции с диском завершается, контроллер возвращает 23 значения, отражающие наличие и типы
    ошибок, которые надо анализировать. Уже одно обращение к процессору громоздко, а анализ ошибок и вовсе
    представляется невообразимым, особенно, если не именно с этим процессором приходится работать. Вообще набор
    команд машинного языка сильно зависит от типа процессора.</p>

<h2>Язык ассемблера </h2>

<p>На протяжении 1950-х годов запросы на разработку программного обеспечения возросли и программы стали очень
    большими. Приходилось писать очень много кода, хотя обеспечение и было весьма простым: по тем временам дизайн
    рабочего стола был проще нынешнего, программы работали с элементарными вещами, а компьютер только ещё начинал
    победно шествовать. Однако программы запутывались всё больше, их структура усложнилась, потому что всё время
    развивалась компьютерная техника. Тогда стали пользоваться специальными программами-<a
            href="http://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80"
            title="Ассемблер">сборщиками программ</a> из маленьких кусочков кодов&nbsp;— ассемблерами. Начался новый
    этап развития.</p>

<p> Теперь, когда была нужна эффективная программа, вместо машинных языков использовались близкие к ним
    машинно-ориентированные <a
            href="http://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80%D0%B0"
            title="Язык ассемблера">языки ассемблера</a>. К таковым относились, например, Autocode, с 1954-го г.&nbsp;—
    IPL (предшественник языка LISP) и, с 1955-го г.&nbsp;— FLOW-MATIC (предшественник языка COBOL). Теперь люди
    стали использовать мнемонические команды взамен машинных команд.</p>

<p> Но даже работа с ассемблером достаточно сложна и требует специальной подготовки. Например, для процессора <a
        href="http://ru.wikipedia.org/wiki/Zilog_Z80" title="Zilog Z80">Zilog Z80</a> машинная команда 00000101
    предписывает процессору уменьшить на единицу свой регистр B. На языке ассемблера это же будет записано как DEC
    B.</p>

<h2>Языки высокого уровня </h2>

<p>Следующий шаг был сделан в 1954 году, когда был создан первый язык высокого уровня&nbsp;— <a
        href="http://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82%D1%80%D0%B0%D0%BD" title="Фортран">Фортран</a>
    <em>FORTRAN - FORmula TRANslator</em>), а за ним и некоторые другие,
    как LISP, ALGOL 58, FACT (ещё один предшественник языка COBOL). <a
            href="http://ru.wikipedia.org/wiki/%D0%92%D1%8B%D1%81%D0%BE%D0%BA%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"
            title="Высокоуровневый язык программирования">Языки высокого уровня</a> имитируют естественные языки,
    используя некоторые слова разговорного языка и общепринятые математические символы. Эти языки более удобны для
    человека, с помощью них, можно писать программы до нескольких тысяч строк длиной. Конечно, это достижение было
    очень ценно. Условными словами можно было, как привычно человеку, гораздо более просто выразить сложную
    программную операцию из битов. Однако, легко понимаемый в коротких программах, этот язык становился нечитаемым и
    трудно управляемым, когда дело касалось больших программ. То есть, простоты по-прежнему не хватало. Решение этой
    проблемы пришло после изобретения языков структурного программирования
    <em>structured programming language</em>), таких как
    <a href="http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D0%BB" title="Алгол">Алгол</a> (1958), <a
            href="http://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D1%8C_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)"
            title="Паскаль (язык программирования)">Паскаль</a> (1970), <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)"
            title="Си (язык программирования)">Си</a> (1972).<br>
    1959-й год&nbsp;— <a href="http://ru.wikipedia.org/wiki/COBOL" title="COBOL">COBOL</a>.<br>
    1962-й год&nbsp;— <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D1%83%D0%BB%D0%B0"
                         title="Симула">Симула</a>.
    С него началась эпоха <em>структурного программирования</em>.</p>

<h2>Появление структурного программирования </h2>

<p>К тому времени люди начали понимать, что создание программного обеспечения&nbsp;— гораздо более сложная задача,
    чем они себе представляли. Это привело к разработке <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Структурное программирование">структурного программирования</a>. С развитием структурного
    программирования следующим достижением были <a
            href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Процедура (программирование)">процедуры</a> и <a
            href="http://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Функция (программирование)">функции</a>. То есть, если есть задача, которая выполняется несколько
    раз, то её можно объявить как функцию или как процедуру и в выполнении программы просто вызывать её. Общий код
    программы в данном случае становится меньше. Это способствовало созданию <a
            href="http://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Модуль (программирование)">модульных программ</a>.</p>

<p> А следующим достижением было использование <em>структур</em>, благодаря которым перешли к классам. <a
        href="http://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
        title="Структура (программирование)">Структуры</a>&nbsp;— это составные типы данных, построенные с
    использованием других типов. Например, структура времени: в неё входят: часы, минуты, секунды. Свою очередь и
    часы, и минуты, и секунды&nbsp;— они описаны при помощи других, более простых и более элементарных типов. Вместо
    сложной работы надо множеством типов, из которых каждый может быть со своими ограничениями&nbsp;— и что подходит
    одному типу, запрещено в другом,&nbsp;— вместо того программист бы мог создать структуру «время» и работать с
    ней, как с единым типом, где нету исключений и один формат.</p>

<p> Свою очередь, <a
        href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B0%D1%81%D1%81_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
        title="Класс (программирование)">Класс</a>&nbsp;— это структура, у которой свои переменные и функции,
    которые работают с этими переменными. То есть, это может быть названо особою средою, отличною ото других
    классов. Все классовые члены одного типу. См. подробнее статью.<br>
    Коротко, это достижение в области программирования было очень велико. Теперь программирование можно было разбить
    на классы и тестировать не всю программу, состоящую из 10 000 строк кода, а разбить программу на 100 классов, и
    тестировать каждый класс. Это существенно облегчило написание программного продукта.</p>

<p> Структурное программирование предполагает точно обозначенные управляющие структуры, <a
        href="http://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D0%BA_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
        title="Блок (программирование)">программные блоки</a>, отсутствие инструкций безусловного перехода
    (GOTO), автономные подпрограммы, поддержка рекурсии и локальных переменных.<br>
    Суть такого подхода заключается в возможности разбиения программы на составляющие элементы.<br>
    Также создавались <em>функциональные</em> (аппликативные) языки (Пример:
    <a href="http://ru.wikipedia.org/wiki/Lisp" title="Lisp">Lisp</a> - <em>LISt Processing</em>, 1958) и
    <em>логические</em> языки (пример: <a href="http://ru.wikipedia.org/wiki/Prolog" title="Prolog">Prolog</a>&nbsp; -
    <em>PROgramming in LOGic</em>, 1972).</p>

<p> Хотя структурное программирование, при его использовании, дало выдающиеся результаты, даже оно оказывалось
    несостоятельным тогда, когда программа достигала определенной длины. Для того чтобы написать более сложную (и
    длинную) программу, нужен был новый подход к программированию.</p>

<h2>
    <a href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
       title="Объектно-ориентированное программирование">ООП</a></h2>

<p>В итоге в конце 1970-х и начале 1980-х были разработаны принципы <a
        href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
        title="Объектно-ориентированное программирование">объектно-ориентированного программирования</a>. ООП
    сочетает лучшие принципы структурного программирования с новыми мощными концепциями, базовые из которых
    называются <a
            href="http://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Инкапсуляция (программирование)">инкапсуляцией</a>, <a
            href="http://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Полиморфизм (программирование)">полиморфизмом</a> и <a
            href="http://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Наследование (программирование)">наследованием</a>.</p>

<p> Примерами объектно-ориентированных языков являются <a href="http://ru.wikipedia.org/wiki/Object_Pascal"
                                                          title="Object Pascal">Object Pascal</a>, <a
        href="http://ru.wikipedia.org/wiki/C%2B%2B" title="C++">C++</a>, <a
        href="http://ru.wikipedia.org/wiki/Java" title="Java">Java</a>, <a
        href="http://ru.wikipedia.org/wiki/C_Sharp" title="C Sharp">C#</a> и др.<br>
    ООП позволяет оптимально организовывать программы, разбивая проблему на составные части, и работая с каждой по
    отдельности. Программа на объектно-ориентированном языке, решая некоторую задачу, по сути, описывает часть мира,
    относящуюся к этой задаче.<br>
    ООП возникло в результате развития идеологии <a
            href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Процедурное программирование">процедурного программирования</a>, где данные и подпрограммы
    (процедуры, функции) их обработки формально не связаны. Для дальнейшего развития объектно-ориентированного
    программирования часто большое значение имеют понятия события (так называемое <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Событийно-ориентированное программирование">событийно-ориентированное программирование</a>) и
    компонента (<a
            href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Компонентное программирование">компонентное программирование</a>, КОП).<br>
    Взаимодействие объектов происходит посредством <a
            href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5#.D0.A1.D0.BE.D0.BE.D0.B1.D1.89.D0.B5.D0.BD.D0.B8.D0.B5">сообщений</a>.
    Результатом дальнейшего развития ООП, по-видимому, будет <a
            href="http://ru.wikipedia.org/wiki/%D0%90%D0%B3%D0%B5%D0%BD%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4"
            title="Агентно-ориентированный подход">агентно-ориентированое программирование</a>, где <em>агенты</em>&nbsp;—
    независимые части кода на уровне выполнения. Взаимодействие агентов происходит посредством изменения
    <em>среды</em>, в которой они находятся.</p>

<p> Языковые конструкции, конструктивно не относящиеся непосредственно к объектам, но сопутствующие им для их
    безопасной (<a
            href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9"
            title="Обработка исключений">исключительные ситуации</a>, проверки) и эффективной работы,
    инкапсулируются от них в аспекты (в <a
            href="http://ru.wikipedia.org/wiki/%D0%90%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Аспектно-ориентированное программирование">аспектно-ориентированном программировании</a>). <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Субъектно-ориентированное программирование">Субъектно-ориентированное программирование</a>
    расширяет понятие объекта посредством обеспечения более унифицированного и независимого взаимодействия объектов.
    Может являться переходной стадией между ООП и агентным программированием в части самостоятельного их
    взаимодействия.</p>

<p> Первым языком программирования, в котором были предложены принципы объектной ориентированности, была <a
        href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D1%83%D0%BB%D0%B0" title="Симула">Симула</a>. В
    момент его появления в <a href="http://ru.wikipedia.org/wiki/1967_%D0%B3%D0%BE%D0%B4" title="1967 год">1967
        году</a> в нём были предложены революционные идеи: объекты, классы, <a
            href="http://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4"
            title="Виртуальный метод">виртуальные методы</a> и др., однако это всё не было воспринято современниками
    как нечто грандиозное. Тем не менее, большинство концепций были развиты <a
            href="http://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D0%B9,_%D0%90%D0%BB%D0%B0%D0%BD_%D0%9A%D1%83%D1%80%D1%82%D0%B8%D1%81"
            title="Кэй, Алан Куртис">Аланом Кэем</a> и <a
            href="http://ru.wikipedia.org/w/index.php?title=%D0%98%D0%BD%D0%B3%D0%B0%D0%BB%D0%BB%D1%81,_%D0%94%D1%8D%D0%BD&action=edit&redlink=1"
            title="Ингаллс, Дэн (страница отсутствует)">Дэном Ингаллсом</a> в языке <a
            href="http://ru.wikipedia.org/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>. Именно он стал первым
    широко распространённым <a
            href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"
            title="Объектно-ориентированный язык программирования">объектно-ориентированным языком
        программирования</a>.</p>

<p> В настоящее время количество прикладных языков программирования (<a
        href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F#.D0.A1.D0.BF.D0.B8.D1.81.D0.BE.D0.BA_.D1.8F.D0.B7.D1.8B.D0.BA.D0.BE.D0.B2"
        title="Объектно-ориентированный язык программирования">список языков</a>), реализующих
    объектно-ориентированную парадигму, является наибольшим по отношению к другим парадигмам. В области системного
    программирования до сих пор применяется парадигма процедурного программирования, и общепринятым языком
    программирования является <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)"
            title="Си (язык программирования)">Cи</a>. При взаимодействии системного и прикладного уровней
    операционных систем заметное влияние стали оказывать языки объектно-ориентированного программирования. Например,
    одной из наиболее распространённых библиотек мультиплатформенного программирования является
    объектно-ориентированная библиотека <a href="http://ru.wikipedia.org/wiki/Qt" title="Qt">Qt</a>, написанная на
    языке <a href="http://ru.wikipedia.org/wiki/C%2B%2B" title="C++">C++</a>.</p>

<p><strong>История</strong></p>

<p>Программирование можно рассматривать как искусство, науку, ремесло. Программирование — это искусство получения
    ответов от машины. Для этого в узком смысле нужно составить специальный код для технического устройства, а в широком
    — разработать программы на языках программирования, т. е. не просто составить код, а выполнить интеллектуальную
    работу по составлению высокоразумных программ для решения различных задач во всех сферах человеческой
    деятельности.<br>
    Программирование — процесс описания последовательности действий решения задачи средствами конкретного языка
    программирования и оформление результатов описания в виде программы. Эта работа требует точности, аккуратности и
    терпения. Команды машине должны формулироваться абсолютно четко и полно, не должны содержать никакой
    двусмысленности.<br>
    На начальном этапе составлением программ для ЭВМ занимались сами изготовители вычислительных машин. Постепенно, с
    развитием техники, этот процесс из рутинной работы превратился в интеллектуальную деятельность, сравнимую с
    искусством, т. к. трудоемкое, ручное составление программ было подобно решению сложных комбинационных задач, которое
    требовало научных знаний и мастерства. Возникла потребность в людях со специальной подготовкой и особым складом ума,
    которых называют программистами. Овладев необходимыми знаниями, научившись грамотно и творчески применять их в
    повседневной работе, программист может стать незаменимым специалистом в своей области деятельности. Отмечается, что
    «программист должен обладать способностью первоклассного математика к абстрактному и логическому мышлению в
    сочетании с эдисоновским талантом сооружать все что угодно из О и 1. Он должен сочетать аккуратность бухгалтера с
    проницательностью разведчика, фантазию автора детективов с трезвой практичностью экономиста».<br>
    Программист — одна из самых востребованных специальностей в современном обществе.</p>

<p>
    С 1970—1980-х гг. программирование как новая научная дисциплина  занимается   методами  разработки   программных 
    продуктов. Оно включает комплекс вопросов, связанных с написанием специ­фикаций, проектированием, кодированием,
    тестированием и функ­ционированием программ для ЭВМ. Для разработки программного обеспечения применяются следующие
    методы: математические, ин­женерных расчетов и управления.<br>
    Уровень программирования определяется четырьмя взаимосвя­занными факторами развития: возможностями компьютеров,
    теори­ей и языками, искусством и технологией программирования.<br>
    Профессиональное программирование — вполне прагматичная деятельность, направленная на получение реального
    программного продукта, которое требует высокой теоретической подготовленности не только в области знания языков
    программирования и принципов создания программ, но и в области математики, системного анализа, исследования
    операций, системотехники и др. Программист должен хорошо ориентироваться в уже имеющемся программном обеспечении
    вычислительной техники и автоматизированных систем, программной защите информации, стандартизации и лицензирова­нии
    программных продуктов.<br>
    Системным программированием, т. е. разработкой средств сис­темного программного обеспечения (ПО) и системы
    программирова­ния, занимаются системные программисты. Прикладным програм­мированием, т. е. разработкой прикладных
    программ, занимаются прикладные программисты. Умение хорошо программировать — ос­новное условие успешной
    профессиональной деятельности программиста. Научиться этому можно, лишь многократно программируя разные задачи,
    проходя путь от ее постановки до работающей программы.<br>
    Для непосредственного решения задач программист должен:<br>
    •   осознать задачу;<br>
    •   составить план общего решения;<br>
    •   выполнить план, т. е. преобразовать его в определенную по­следовательность действий;<br>
    •   проверить результат решения, убедиться в его правильности. Чтобы все это выполнить, специалист должен многое
    знать и<br>
    уметь.</p>

<p>&nbsp;</p>

<p>С глубокой древности известны попытки создать устройства, ус­коряющие и облегчающие процесс вычислений. Еще древние
    греки и римляне применяли приспособление, подобное счетам, — абак. Такие устройства были известны и в странах
    Древнего Востока. В XVM в. немецкие ученые В. Шиккард (1623), Г.Лейбниц (1673) и французский ученый Б. Паскаль
    (1642) создали механические вы­числительные устройства — предшественники всем известного арифмометра. Вычислительные
    машины совершенствовались в те­чение нескольких веков. Но при этом не применялось понятие «программа и
    программирование».<br>
    Только в начале XIX в. (1830) английский ученый, профессор математики Кэмбриджского университета Чарльз Бэббидж,
    анализи­руя результаты обработки переписи населения во Франции, теорети­чески исследовал процесс выполнения
    вычислений и обосновал ос­новы архитектуры вычислительной машины. Работая над проектом аналитической машины —
    «Машины для исчисления разностей», Ч. Бэббидж предсказал многие идеи и принципы организации и работы современных
    ЭВМ, в частности принцип программного управления и запоминаемой программы. Общая увлеченность наукой дала ученому и
    Аде Лавлейс (1815—1852) долгие годы плодотворного со­трудничества. В 1843 г. она перевела статью Менабреа по лекциям
    Ч. Бэббиджа, где в виде подробных комментариев (по объему они превосходили основной текст) сформулировала главные
    принципы программирования аналитической машины. Она разработала первую программу (1843) для машины Бэббиджа, убедила
    его в необходимо­сти использования в изобретении двоичной системы счисления вме­сто десятичной, разработала принципы
    программирования, предусматривающие повторение одной и той же последовательности команд при определенных условиях.
    Именно она предложила термины «рабочая ячейка» и «цикл». А. Лавлейс составила первые программы для решения системы
    двух уравнений и вычисления чисел Бернулли по довольно сложному алгоритму и предположила, что со временем
    аналитическая машина будет сочинять музыкальные произведения, рисовать картины и использоваться в практической и
    научной дея­тельности. Время подтвердило ее правоту и точность прогнозов. Своими работами А. Лавлейс заложила
    теоретические основы про­граммирования и по праву считается первым в мире программистом и основоположником научного
    программирования.<br>
    В 1854 г. английский математик Джордж Буль опубликовал кни­гу «Законы мышления», в которой развил алгебру
    высказываний —Булеву алгебру. На ее основе в начале 80-х гг. XIX в. построена тео­рия релейно-контактных схем и
    конструирования сложных дискрет­ных автоматов. Алгебра логики оказала многогранное влияние на развитие
    вычислительной техники, являясь инструментом разработ­ки и анализа сложных схем, инструментом оптимизации большого
    числа логических элементов, из многих тысяч которых состоит со­временная ЭВМ.<br>
    Идеи Ч. Бэббиджа реализовал американский ученый Г. Холлерит, который с помощью построенной счетно-аналитической
    маши­ны и перфокарт за три года обработал результаты переписи населе­ния в США по состоянию на 1890 г. В машине
    впервые было ис­пользовано электричество. В 1896 г. Холлеритом была основана фирма по выпуску вычислительных
    перфорационных машин и пер­фокарт.<br>
    В 1936 г. английский математик А. Тьюринг ввел понятие ма­шины Тьюринга, как формального уточнения интуитивного
    понятия алгоритма. Ученый показал, что любой алгоритм в некотором смысле может быть реализован на машине Тьюринга, а
    следователь­но, доказывал возможность построения универсальной ЭВМ. И та, и другая машины аналогично могут быть
    снабжены исходными данными решаемой задачи и программой ее решения. Машину Тьюринга можно считать как бы
    идеализированной моделью универ­сальной ЭВМ.<br>
    В 40-х гг. XX в. механическая элементная база вычислительных машин стала заменяться электрическими и электронными
    устройствами. Первые электромеханические машины были созданы в Германии К. Цузе (Ц-3, 1941 г.) и в США под
    руководством профессора Гарвардского университета Г. Айкена (МАРК-1, 1944 г.). Первая электронная машина создана в
    США группой инженеров под руководством доктора Пенсильванского университета Дж. Мочли и аспиранта Дж. Экксрта (ЭНИАК
    — электронный числовой интегратор и калькулятор, 1946 г.). В 1949 г. в Англии была построена EDSAC — первая машина,
    обладающая автоматическим программным управ­лением, внутренним запоминающим устройством и другими необхо­димыми
    компонентами современных ЭВМ.<br>
    Логические схемы вычислительных машин были разработаны в конце 1940-х гг. Дж. фон Нейманом, Г. Гольдстайном и А. В.
    Берксом. Особый вклад в эту работу внес американский математик Джон фон Нейман, принимавший участие в создании
    ЭНИАК. Он предложил идею хранения команд управления и данных в машин­ной памяти и сформулировал основные принципы
    построения современных ЭВМ. ЭВМ с хранимой программой оказались более быстродействующими и гибкими, чем ранее
    созданные.<br>
    В 1951 г. в США было налажено первое серийное производство электронных машин УНИВАК (универсальная автоматическая
    вы­числительная машина). В это же время фирма IBM начала серий­ный выпуск машины IBM/701.<br>
    В СССР первыми авторами ЭВМ, изобретенной в декабре 1948 г., являются И. С. Брук и Б. И. Рамеев. А первая советская
    ЭВМ с сохраняющейся программой создана в 1951 г. под руково­дством С. А Лебедева (МЭСМ — малая электронная счетная
    маши­на). В 1953 г. в Советском Союзе начался серийный выпуск машин, первыми их которых были БЭСМ-1, «Стрела».<br>
    С появлением цифровых программно-управляемых машин родилась новая область прикладной математики — программирование.
    Как область науки и профессия она возникла в 1950-х гг. Первона­чально программы составлялись вручную на машинных
    языках (в машинных кодах). Программы были громоздки, их отладка — очень трудоемка. Для упрощения приемов и методов
    составления и отладки программ были созданы мнемокоды, по структуре близкие к машинному языку и использующие
    символьную адресацию. Ассемблеры переводили программу, записанную в мнемокоде, на машинный язык и, расширенные
    макрокомандами, используются и в настоящее время. Далее были созданы автокоды, которые можно применять на различных
    машинах, и позволившие обмениваться программами. Автокод — набор псевдокоманд для решения специализиро­ванных задач,
    например научных или инженерных. Для таких задач имеется развитая библиотека стандартных программ.<br>
    До конца 1950-х гг. ЭВМ основным элементом конструкции были электронные лампы (1-е поколение). В этот период
    развитие идеологии и техники программирования шло за счет достижений американских ученых Дж. фон Неймана,
    сформулировавшего ос­новные принципы построения ЭВМ, и Дж. Бэкуса, под руково­дством которого в 1954 г. был создан
    Fortran (Formula Translation) — первый язык программирования высокого уровня, используемый до настоящего времени в
    разных модификациях. Так, в 1965 г. в Дартмутском колледже Д. Кэмэни и Т. Куртцем была разработана упро­щенная
    версия Фортрана — Basic. В 1966 г. комиссия при Амери­канской ассоциации стандартов (ASA) разработала два стандарта
    языка: Фортран и Базисный Фортран. Используются также даль­нейшие модификации языка (например 1970, 1990 гг.).<br>
    Достижения в области электроники и микроэлектроники по зволили заменить элементную базу ЭВМ на более совершенную. В
    конце 1950-х гг. громоздкие электронные лампы заменяют полу­проводниками (миниатюрными транзисторами). Появляются
    ЭВМ II поколения; затем примерно через 10 лет — ЭВМ III поколения на интегральных схемах; еще через 10 лет — ЭВМ IV
    поколения на больших интегральных схемах (БИС). В Японии в 1990-х гг. реали­зованы проекты ЭВМ V поколения, в
    которых использованы дос­тижения в области искусственного интеллекта и биоэлектроники. Если объем оперативного
    запоминающего устройства (ОЗУ) одной из лучших отечественных машин 1960-х гг. М-20, созданной под руководством
    С.А.Лебедева в 1958 г., имел 4096 слов (8 Кбайт) и быстродействие 20 тыс. операций в секунду, то современные
    персо­нальные компьютеры характеризуются ОЗУ в десятки Мбайт и бы­стродействием в сотни миллионов операций в
    секунду, что позво­ляет решать сложнейшие задачи.<br>
    В 1953 г. А.А.Ляпуновым был предложен операторный метод программирования, который заключался в автоматизации
    программирования, а алгоритм решения задачи представлялся в виде совокупности операторов, образующих логическую
    схему задачи. Схемы позволяли расчленить громоздкий процесс составления программы, части которой составлялись по
    формальным правилам, а затем объединялись в целое. Для проверки идей операторного метода в СССР в 1954 г. была
    разработана первая программирующая про­грамма ПП-1, а в 1955 г. более совершенная — ПП-2. В 1956 г. разработана ПП
    БЭСМ, в 1957 г. - ППСВ, в 1958 г. — для машины «Стрела».<br>
    В США в 1954 г. стал применяться алгебраический подход, совпадающий, по существу, с операторным методом. В 1956 г.
    корпора­цией IBM разработана универсальная ПП Фортран для автоматического программирования на ЭВМ IBM/704.<br>
    В этот период по мере накопления опыта и теоретического осмысления совершенствовались языки программирования. В
    1958—1960 гг. в Европе был создан ALGOL, который породил целую серию алголоподобных языков: Algol W, (1967), Algol
    68, Pascal (Н. Вирт, 1970 г.), С (Д. Ритчи и Б. Керниган, 1972 г.), Ada (под ру­ководством Ж. Ишбиа, 1979 г.), C++
    (1983). В 1961-1962 гг. Дж. Маккарти в Массачусетс ком технологическом институте был создан язык функционального
    программирования Lisp, открывший в программировании одно из альтернативных направлений, предло­женных Дж. фон
    Нейманом.<br>
    На начало 1970-х гг. существовало более 700 языков высокого уровня и около 300 трансляторов для автоматизации
    программирования.<br>
    Усложнение структуры ЭВМ привело (в 1953 г. для машин И-го поколения) к созданию операционных систем (ОС) —
    специальных управляющих программ для организации и решения задач на ЭВМ. Например, мониторная система МТИ, созданная
    в Массачусетском технологическом институте, обеспечивала пакетную обработку, т. е. непрерывное, последовательное
    прохождение через ЭВМ многих групп (пакетов) заданий и пользование библиотекой служебных программ, хранимой в
    машине. Это позволило совместить операции по запуску с выполнением программ.<br>
    Для ПЭВМ к настоящему времени разработаны ОС: MS DOS, Windows, ОС/2, МасОС, Unix, Linux и др. Широкое
    распростране­ние получили ОС MS DOS и Windows, имеющие развитый интер­фейс и широкий набор приложений, позволяющих
    последователь­ное выполнение заданий из пакета, обработку различной информа­ции во многих сферах человеческой
    деятельности.<br>
    В 1965 г. итальянцы Бом и Джакопини предложили использо­вать в качестве базовых алгоритмических элементов
    следование, ветвление и цикл. Почти в то же время к аналогичным выводам пришел голландский ученый Э. Дийкстра,
    заложивший основы структурного программирования. В 1970-х гг. эта методология оформилась, и корпорация IBM сообщила
    о применении в разра­ботке программного обеспечения «Усовершенствованных методов программирования», одним из
    компонентов которых являлась тех­нология нисходящего структурного программирования (структур­ного программирования),
    основу которого составляет следующее:<br>
    • сложная задача разбивается на простые, функционально управляемые задачи, каждая задача имеет один вход и один
    выход; управляющий поток программы состоит из совокуп­ности элементарных функциональных подзадач;<br>
    • управляющие структуры просты, т. е. логическая задача долж­на состоять из минимальной, функционально полной
    сово­купности достаточно простых управляющих структур;<br>
    • программа разрабатывается поэтапно, на каждом этапе реша­ется ограниченное число точно поставленных задач.<br>
    Четко сформулированные основы нисходящей разработки, структурного кодирования и сквозного контроля позволяли перейти
    к промышленным методам разработки программного обеспечения.<br>
    Развитие получило модульное программирование, основа которого заключается в следующем:<br>
    • функциональная декомпозиция (разбиение) задачи на самостоятельные подзадачи — модули, связанные только входны­ми и
    выходными данными; <br>
    • модуль  представляет собой   «черный  ящик»,   позволяющий разрабатывать части программ одного проекта на разных
    язы­ках программирования, а затем с помощью компоновочных средств объединять их в единый загрузочный модуль;<br>
    • должно быть ясное понимание назначения всех модулей зада­чи и их оптимального сочетания;<br>
    • с помощью комментариев должно описываться назначение всех переменных модуля.<br>
    В период 1970—1980-х гг. развитие теоретических исследований оформило программирование как самостоятельную научную
    дисциплину, занимающуюся методами разработки программного обеспечения (ПО).<br>
    В истории развития промышленного программирования боль­шую роль сыграл программист и бизнесмен Билл Гейтс (Gates
    William Henry, p. в 1955 г.). Его история очень поучительна для на­чинающих программистов. В 1972 г. Билл Гейтс и
    его школьный то­варищ Пол Аллен основали компанию по анализу уличного движе­ния «Трэф-О-Дейта» и использовали для
    обработки данных компь­ютеры с микропроцессором 8008 — первым из знаменитого ряда микропроцессоров компании «Intel».
    Будучи студентом Гарвардско­го университета, в 1975 г. он совместно с Алленом написал для ком­пьютера Altair (фирмы
    M1TS) интерпретатор — программу-перево­дчик с языка программирования на язык машинных кодов. Они за­ключили с
    владельцем фирмы соглашение, по которому их программы распространялись вместе с компьютерами. Товарищи основали
    компанию «Microsoft», в которой Б. Гейтсу принадлежало 60 % акций, П. Аллену — 40 %. В 1976 г. Гейтс ввел в практику
    про­дажу лицензий на свои программные продукты непосредственно производителям компьютеров, что позволило
    «встраивать» их (ОС и трансляторы с языков программирования) в компьютеры. Это было большое достижение в области
    маркетинга, принесшее фирме ог­ромные доходы. Фирма привлекала таких новых заказчиков, как фирмы «Apple»,
    «Commodor», «Tendi». В 1980 г. фирма IBM предло­жила «Microsoft», в которой тогда работало около двух десятков
    че­ловек, создать языки программирования для ее нового персональ­ного компьютера, в дальнейшем известным как IBM PC.
    В 1981 г. «Microsoft» приобрела у разработчика Т. Патерсона дисковую ОС (DOS), и в августе этого года IBM PC
    поставлялась вместе с ОС MS DOS. Успех был настолько велик, что, кроме значительных доходов, привел к тому, что и
    архитектура Intel, и компьютеры IBM, и про­граммы «Microsoft» фактически стали отраслевыми стандартами. В 1988 г.
    «Microsoft» создала свою ОС Windows с мощным графическим интерфейсом. К 1995 г. ОС, выпускаемые фирмой,
    использо­вали 85 % персональных компьютеров. ОС Windows совершенству­ется год от года, обладая уже средствами
    доступа в глобальную сеть Internet. Вместе с фирмой NBC был создан круглосуточный кабель­ный информационный канал
    новостей. Совместно с фирмой «Эн-карта» создана мультимедиа-энциклопедия на CD-ROM «Книжная полка», содержащая
    электронные версии семи больших справочни­ков, электронную энциклопедию кино — «Синемания». В 1995 г. в фирме
    «Microsoft» работало 18 тыс. человек, годовой выпуск достиг 200 программных продуктов, а доходы составили миллиарды
    долла­ров. В 1998 г. Б. Гейтс стал самым богатым человеком в мире, а в конце 1999 г. — объявил о своем решении уйти
    с поста главы ком­пании и заняться программированием. Сегодня Билл Гейтс — одна из самых популярных фигур
    компьютерного мира. Журнал «People» писал: «Гейтс в сфере программирования значит столько же, сколь­ко Эдисон в
    отношении к электрической лампочке: отчасти инноватор, отчасти предприниматель, отчасти торговец, но неизменно
    гений».<br>
    Профессиональное программирование вышло на уровень техно­логии. Методы разработки ПО синтезируют:<br>
    •   методы инженерных расчетов для оценки затрат и выбора ре­шений;<br>
    •   математические методы для составления алгоритмов;<br>
    •   методы управления для определения требований к системе, учета ситуаций, организации работ и прогнозирования.<br>
    На смену структурному программированию в начале 1990-х гг. пришло объектно-ориентированное программирование — ООП.
    Его можно рассматривать как модульное программирование нового уровня, когда вместо во многом случайного,
    механического объединения процедур и данных главным становится их смысловая связь. Объект рассматривается как
    логическая единица, которая содержит данные и правила (методы) их обработки. Объектно-ориентированный язык создает
    «программное окружение» в виде множества независимых объектов, каждый из которых отличается своими свойствами и
    способами взаимодействия с другими объектами. Программист задает совокупность операций, описывая структуру обмена
    сообщениями между объектами. Как правило, он «не заглядывает» внутрь объектов, но при необходимости может изменять
    элементы внутри объектов или формировать новые.<br>
    ООП основано на трех важнейших принципах (инкапсуляция, наследование, полиморфизм), придающих объектам новые
    свойства. Инкапсуляция — объединение в единое целое данных и алгоритмов их обработки. Данные здесь — поля объекта, а
    алгоритмы — объектные методы. Наследование — свойство объектов порождать своих потомков. Объект-потомок
    автоматически наследует все поля и методы, может дополнять объекты новыми полями, заменять и дополнять методы.
    Полиморфизм — свойство родственных объектов решать схожие по смыслу проблемы разными способами.<br>
    Идея использования программных объектов исследовалась в течение ряда лет разными учеными. Одним из первых языков
    этого типа считают Simula-67. А в 1972 г. появился язык Smoltalk, разработанный Аланом Кеем, утвердивший статус ООП.<br>
    На современном этапе развиваются инструментальные среды и системы визуального программирования для создания программ
    на языках высокого уровня: (Turbo Pascal, Delphi, Visual Basic, C++Builder и др.).<br>
    Развитие основных принципов объектно-ориентированного программирования получило с появлением компонентного
    программирования (КП). КП — динамический процесс без жестких правил, выполняющийся в основном для распределенной
    разработки (программирования) распределенных систем. Суть КП в том, что независимые проектировщики, программисты
    разрабатывают независимые компоненты (отдельные части) единой системы, распределенные по множеству узлов большой
    сети. Эти части могут принадлежать раз­ным собственникам и управляться организационно независимыми администраторами.<br>
    В КП компонент рассматривается как хранилище (в виде DLL-или ЕХЕ файлов) для одного или нескольких классов. Классы
    рас­пространяются в бинарном виде, а не в виде исходного кода. Пре­доставление доступа к методам класса
    осуществляется через строго определенные интерфейсы по протоколу. Это снимает проблему несовместимости компиляторов,
    обеспечивая без перекомпиляции смену версий классов в разных приложениях. Интерфейсы задают содержание сервиса и
    являются посредником между клиентом и сервером.<br>
    Фирма Microsoft создала технологии для распределенной разра­ботки распределенных систем, такие как COM (Component
    Object Model), COM+, .NET. Разработаны и другие технологии: CORBA (консорциума OMG), JAVA (компании Sun Microsystem)
    и др.</p>

<p> Идея переложить на ЭВМ функции составителей алгоритмов и программистов дала новые возможности развитию сферы
    искусственного интеллекта, которая должна была создавать методы автоматического решения интеллектуальных задач.
    Формализация знаний, которые есть у профессионалов в разных областях, накопление их в базах знаний, реализованных на
    ЭВМ, стали основанием для созда­ния экспертных систем. На основе баз знаний работают и ЭВМ V поколения, и
    интеллектуальные роботы, и экспертные системы. Эти системы могут не только найти решение той или иной задачи, но и
    объяснить, как оно получено. Появилась возможность манипулировать знаниями, иметь знания о знаниях — метазнания.
    Знания, хра-няшиеся в системе, стали объектом ее собственных исследований.</p>

<p> Независимость языков высокого уровня от ЭВМ вовлекла в сферу алгоритмизации задач специалистов различных отраслей
    зна­ний, позволила использовать многочисленные стандартные типовые программы, а программистам — устранять
    дублирование в написа­нии программ для различных типов ЭВМ и значительно повысить производительность труда.</p>

<p>В конце 1980-х гг. в Японии и США появились проекты ЭВМ V поколения, реализованные в конце 1990-х гг. Прогресс в
    програм­мировании связан с прогрессом в архитектуре вычислительных сис­тем, отходом от фон-неймановской концепции, с
    достижениями в области искусственного интеллекта. Революционные изменения в элементной базе ЭВМ связываются с
    исследованиями по биоэлектронике.</p>

<p>На современном этапе программирование включает комплекс вопросов, связанных с написанием спецификаций (условий
    задач), проектированием, кодированием, тестированием и функционирова­нием программ для ЭВМ. Современное ПО для ЭВМ
    имеет слож­ную структуру и включает, как правило, ОС, трансляторы с различ­ных языков, текстовые программы контроля
    и диагностики, набор обслуживающих программ. Например, японские ученые для проек­тирования систем ПО разрабатывают
    идею «кольцевой структуры» шести уровней: 1-й (внутренний) — программы для аппаратуры; 2-й — ядро ОС; 3-й —
    программы сопряжения; 4-й — часть ОС, ориентированная на пользователя; 5-й — системы программирования; 6-й (внешний)
    — программы пользователя.</p>

<p>
    Согласно этим проектам научных исследований планируется упростить процесс создания программных средств путем
    автомати­зации синтеза по спецификациям исходных требований на естест­венных языках. В последнее время в Японии
    удалось создать робо­та-переводчика, переводящего английскую речь на японский язык и наоборот, осуществляя это
    голосом человека. Во всех развитых странах работают над комплексами программ для создания роботов. Для многих сфер
    человеческой деятельности.</p>

<p>
    Широкое применение структурных и объектно-ориентирован­ных методов программирования с использованием графических
    моделей объединялось отсутствием инструментальных средств. Это по­родило потребность в программно-технологических
    средствах спе­циального класса — CASE (Computer Aided Software Engineering), реализующих технологию создания и
    сопровождения ПО различных систем. Предпосылки для появления CASE-технологий возникли к концу 1980-х гг.
    Первоначально термин «CASE» применялся только к вопросам автоматизации разработки ПО, теперь программная инженерия
    имеет более широкое значение для разработки систем в целом. В CASE-технологии входит разработка и внедрение языков
    высокого уровня, методов структурного и модульного программирования, языков проектирования и средств их поддержки,
    формальных и неформальных языков описания системных требований.</p>


<p>&nbsp;</p>

<a href="https://docs.google.com/file/d/1rApWGFnPe3NfCRjNSD8w1-aWlGELjAv7k2VorS6YXmc/edit?usp=sharing">Презентация
    PowerPoint</a>
</div>
</body>
</html>
