<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>Перечислите основные концепции языков программирования (переменная, цикл, функция, процедура, метод, объект,
        класс и т.д.)</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
    <script type="text/javascript" src="../syntax/sh_main.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_cpp.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_xml.min.js"></script>
    <link type="text/css" rel="stylesheet" href="../style/sh_nedit.css">
</head>
<body onLoad="sh_highlightDocument()">
<div id="content">
<h1>Перечислите основные концепции языков программирования (переменная, цикл, функция, процедура, метод, объект, класс и
    т.д.)</h1>

<h2>Переменные</h2>

<p>Переменная - это именованный участок памяти, в котором хранится значение, которое может быть изменено программой. Все
    переменные перед их использованием должны быть объявлены. Общая форма&nbsp;<em>объявления</em><a name="1"></a><a
            href="http://ddsh.ru/msu/c/02/0204.htm#11">[1] </a> &nbsp;имеет такой вид:<br>
    <em>тип  список_переменных;</em></p>

<p>Примеры объявления переменных:</p>

<div> int i,j,l;  (с++)<br>
    var A,B,C:integer;   (Pascal)<br>
    variable sum : integer := 0;(VHDL)
</div>
<p>Каждая переменная имеет тип. </p>

<h3>Типы данных в C</h3>

<p align="center"><img src="img/datatypes.png" alt="33" width="597" height="289" border="0"></p>

<p>Переменной можно присваивать значения этого типа. Числовой переменной нельзя присвоить строку и наоборот.</p>

<p>Переменные по месту определения и области видимости делятся на:
<ul>
    <li>Локальные</li>
    <li>Глобальные</li>
    <li>Формальные параметры функции</li>
</ul>
<h3>Локальные переменные</h3>

<p>Объявляются внутри блоков (функций / циклов и т.д.). Блок программы - описания и инструкции, объединенные в одну
    конструкцию фигурными скобками. Локальная переменная невидима за пределами своего блока.
    <pre class="sh_cpp">
void func1() {
  int x;
  x = 10;
}</pre>
<p>При выходе из функции переменная будет разрушена. переменная, объявленная в одном блоке, не имеет никакого отношения
    к переменной с тем же именем, объявленной в другом блоке.</p>

<h2>Глобальные переменные</h2>

<p>Видимы и могут использоваться в любом месте программы (в пределах модуля). Они сохраняют свое значение на протяжении
    всей работы программы. Объявлять глобальные переменные рекомендуется в верхней части программы.</p>
  <pre class="sh_cpp">
#include &lt;stdio.h&gt;

int count;  // глобальная переменная count

void func1(void);
void func2(void);

int main(void) {
  count = 100;
  func1();
  return 0;
}</pre>
<p>Если локальная и глобальная переменные имеют одно и то же имя, то при обращении к ней внутри блока, в котором
    объявлена локальная переменная, используется локальная переменная, и на глобальную переменную это никак не
    влияет.</p>

<p>Рекомендуется избегать излишнего использования глобальных переменных т.к.:</p>
<ul>
    <li> они занимают память в течение всего времени выполнения программы, а не только тогда, когда они необходимы.</li>
    <li> функция становится менее универсальной, потому что в этом случае функция использует нечто, определенное вне ее
        (side-effects).
    </li>
    <li>при увеличении размера программы серьезной проблемой становится случайное изменение значения переменной где-то в
        другой части программы.
    </li>
</ul>
<h3>Формальные параметры функции</h3>

<p>Если функция имеет аргументы, значит должны быть объявлены переменные, которые примут их значения. Эти переменные
    называются&nbsp;формальными параметрами&nbsp;функции. Внутри функции они фигурируют как обычные локальные
    переменные.</p>
  <pre class="sh_cpp">
void deleteAfterIndex(int index) { // index – параметр функции 
  int  nextIndex=mass[mass[index].next].next;
  mass[mass[index].next].next=-3;  // массив  класса 
  mass[index].next=nextIndex;
}</pre>
<h2>Цикл</h2>

<p><strong>Цикл</strong> - любая многократно исполняемая последовательность инструкций, организованная любым способом
    например, с помощью&nbsp;условного перехода.</p>

<p> Последовательность инструкций, предназначенная для многократного исполнения, называется&nbsp;<strong>телом
    цикла</strong>. Единичное выполнение тела цикла называется&nbsp;<strong>итерацией</strong>.</p>

<p> Исполнение любого цикла включает первоначальную инициализацию переменных цикла, проверку условия выхода, исполнение
    тела цикла и обновление переменной цикла на каждой итерации. Кроме того, большинство языков программирования
    предоставляют средства для досрочного управления циклом, например, операторы завершения цикла, то есть выхода из
    цикла независимо от истинности условия выхода (в языке&nbsp;Си&nbsp;-&nbsp;break) и операторы пропуска итерации (в
    языке Си&nbsp;-&nbsp;continue).</p>

<p><strong>Виды циклов:</strong></p>
<ul>
    <li>Цикл с предусловием</li>
    <li>Цикл с постусловием</li>
    <li>Цикл со счётчиком</li>
</ul>
<h2>Цикл с предусловием&nbsp; </h2>

<p><img src="img/cycle2.jpg" alt="55" width="208" height="200" align="right" hspace="12"><strong>Цикл с
    предусловием</strong>&nbsp;- цикл, который выполняется пока истинно некоторое условие, указанное перед его началом.
    Это условие проверяется&nbsp;до выполнения тела цикла, поэтому тело может быть не выполнено ни разу (если условие с
    самого начала ложно).<br>
<pre class="sh_cpp">
int i(0); 
while (i&lt;15) {
  i++;
  cout &lt;&lt; i &lt;&lt; endl; // &lt;тело цикла&gt; 
}
</pre>
<h2>Цикл с постусловием&nbsp; </h2>

<p><img src="img/cycle.gif" alt="557" width="169" height="189" align="right" hspace="12"><strong>Цикл с
    постусловием</strong>&nbsp;- цикл, в котором условие проверяется&nbsp;после выполнения тела цикла. Отсюда следует,
    что тело&nbsp;всегда выполняется хотя бы один раз.</p>
<pre class="sh_cpp">
 int i(0);
 do {
   i++;// &lt;тело цикла&gt;
 } while(i&lt;15);</pre>
<h2>Цикл со счётчиком</h2>

<p><strong>Цикл со счётчиком</strong>&nbsp;- цикл, в котором некоторая&nbsp;переменная&nbsp;изменяет своё значение от
    заданного начального значения до конечного значения с некоторым шагом, и для каждого значения этой переменной тело
    цикла выполняется один раз. В большинстве процедурных языков программирования реализуется оператором&nbsp;for.<br>
</p>

<div><br>
    for (i = 0; i &lt; 10; ++i)<br>
    {<br>
    cout&lt;&lt;i&lt;&lt;endl;// тело цикла <br>
    }
</div>
<h2>Вложенные циклы </h2>

<p>Существует возможность организовать цикл внутри тела другого цикла. Такой цикл будет называться&nbsp;вложенным
    циклом. Вложенный цикл по отношению к циклу в тело которого он вложен будет именоваться&nbsp;внутренним циклом, и
    наоборот цикл в теле которого существует вложенный цикл будет именоваться&nbsp;внешним&nbsp;по отношению к
    вложенному. Внутри вложенного цикла в свою очередь может быть вложен еще один цикл, образуя следующий&nbsp;уровень
    вложенности&nbsp;и так далее. Количество уровней вложенности, как правило, не ограничивается. <br>
    Пример на Си: (вычисление определителя матрицы методом Гаусса)</p>

<div><br>
    int i(0), j(0), k(0), x[row1][col1], y[row2][col2], z[row1][col2];
    <p>for (i = 0; i&lt;row1;i++){<br>
        for (j = 0;j&lt;col2; j++){<br>
        z[i][j]=0;<br>
        for (k=0;k&lt;col1; k++){<br>
        z[i][j] =  z[i][j] + x[i][k]*y[k][j];<br>
        }<br>
        }<br>
        }</p>
</div>
<div>
    <p>Функции </p>
</div>
<p>Функция - это совокупность объявлений и операторов, обычно предназначенная для решения определенной задачи. Функция
    может принимать параметры и возвращать значение некоторого типа. <br>
    Функция может также не возвращать никаких значений (процедура), для этого ее тип должен быть void, может не
    принимать значений, тогда список параметров должен отсутствовать.<br>
    Определение функции имеет следующую форму:</p>

<div><br>
    [спецификатор-типа] имя-функции(список-формальных-параметров)<br>
    {<br>
    тело-функции <br>
    }
</div>
<p>Пример на Си:</p>

<div>
    <p>#include &lt;iostream&gt;<br>
        using namespace std;</p>

    <p>int sum(int a, int b);          // объявление функции, ее можно сразу же описать</p>

    <p>int main() {<br>
        int a = 2, b = 3, c, d;<br>
        c = sum(a, b);              // вызов функции<br>
        cin &gt;&gt; d;<br>
        cout &lt;&lt; sum(c, d);          // вызов функции <br>
        return 0;<br>
        }<br>
        //тип функции- int, это значит что функция должна возвратить значение типа int<br>
        int sum(int a, int b) {         // определение функции <br>
        return (a + b);   <br>
        }</p>
</div>
<h2>Виды передачи величин в функцию</h2>

<p>&nbsp;</p>

<p>Существует два вида передачи величин в функцию: по значению и по адресу.<br>
    При передаче&nbsp;по значению&nbsp;в стек заносятся копии значений фактических параметров, и операторы функции
    работают с этими копиями. Доступа к исходным значениям параметров у функции нет, а, следовательно, нет и возможности
    их изменить.<br>
    При передаче&nbsp;по адресу&nbsp;в стек заносятся копии адресов параметров, а функция осуществляет доступ к ячейкам
    памяти по этим адресам и может изменить исходные значения параметров:</p>

<div><br>
    #include &lt;iostream&gt;<br>
    using namespace std;
    <p>void f(int i, int* j, int&amp; k);</p>

    <p>int main() {<br>
        int i = 1, j = 2, k = 3;<br>
        cout &lt;&lt; &quot;i j k\n&quot;;<br>
        cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k &lt;&lt; '\n';<br>
        f(i, &amp;j, k);<br>
        cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k;<br>
        return 0;<br>
        }</p>

    <p>void f(int i, int* j, int&amp; k) {<br>
        i++;<br>
        (*j)++;<br>
        k++;<br>
        }</p>
</div>
<p>    <br>
    Результат работы программы: <br>
    i  j k<br>
    1 2 3<br>
    1 3 4</p>
<pre>    </pre>
<div>
    <p>Процедуры</p>
</div>
<p>Процедура - понятие, которое используется в большинстве языков программирования высокого уровня, и соответствует
    значению подпрограмма. Процедура – функция, не возвращающая значение.<br>
    В языке Си процедуре соответствует функция с типом void. Поэтому си-разработчики не подозревают о существовании
    такого термина. Однако процедуры широко используются в языке Pascal. <br>
    Формат описания процедуры имеет вид:</p>

<div><br>
    <a name="2">procedure имя процедуры (формальные параметры);</a><br>
    раздел описаний процедуры<br>
    begin<br>
    исполняемая часть процедуры<br>
    end;
</div>
<p>Пример на Pascal:</p>

<div><br>
    procedure MaxNumber(a,b: integer; var max: integer);<br>
    begin<br>
    if a&gt;b then max:=a else max:=b;<br>
    end;
</div>
<div>
    <p>Класс</p>
</div>
<p>Класс — это тип, описывающий устройство объектов. Понятие «класс» подразумевает некоторое поведение и способ
    представления. Понятие «объект» подразумевает нечто, что обладает определённым поведением и способом представления.
    Говорят, что объект — это экземпляр класса. Класс можно сравнить с чертежом, согласно которому создаются объекты.
    Обычно классы разрабатывают таким образом, чтобы их объекты соответствовали объектам предметной области.<br>
    Классы в С++&nbsp;- это абстракция описывающая методы, свойства, ещё не существующих объектов.&nbsp;Объекты&nbsp;-
    конкретное представление абстракции, имеющее свои свойства и методы. Созданные объекты на основе одного класса
    называются экземплярами этого класса. Эти объекты могут иметь различное поведение, свойства, но все равно будут
    являться объектами одного класса.</p>

<h2>&nbsp;Три основных принципа построения классов</h2>
<ul>
    <li>Инкапсуляция&nbsp;-&nbsp;это свойство, позволяющее объединить в классе и данные, и методы, работающие с ними и
        скрыть детали реализации от пользователя.
    </li>
    <li>Наследование&nbsp;-&nbsp;это свойство, позволяющее создать новый класс-потомок на основе уже существующего, при
        этом все характеристики класса родителя присваиваются классу-потомку.
    </li>
    <li>Полиморфизм&nbsp;-&nbsp;свойство классов, позволяющее использовать объекты классов с одинаковым интерфейсом без
        информации о типе и внутренней структуре объекта.
    </li>
</ul>
<h2>Структуру объявления классов</h2>

<p>&nbsp;</p>

<div>
    <p>// объявление классов в С++<br>
        class /*имя класса*/<br>
        {<br>
        &nbsp;&nbsp;private:<br>
        &nbsp;&nbsp;/* список свойств и методов для использования внутри класса */<br>
        &nbsp;&nbsp;public:<br>
        &nbsp;&nbsp;/* список методов доступных другим функциям и объектам программы */<br>
        &nbsp;&nbsp;protected:<br>
        &nbsp;&nbsp;/*список средств, доступных при наследовании*/<br>
        };</p>
</div>
<p>Пример на Си++:<a name="_GoBack"></a></p>

<div><br>
    #include &lt;iostream&gt;<br>
    using namespace std;<br>
    // начало объявления класса<br>
    class mouse_4tech&nbsp;// имя класса <br>
    {<br>
    public:&nbsp;// спецификатор доступа<br>
    &nbsp;&nbsp;&nbsp;&nbsp;void who_i_am()&nbsp;// функция (метод класса) выводящая сообщение на экран<br>
    &nbsp;&nbsp;&nbsp;&nbsp;{<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;&nbsp;&quot;I&rsquo;m mouse A4tech\n&quot;;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
    };&nbsp;// конец объявления класса
    <p>int main()<br>
        {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;mouse_4tech obj1;&nbsp;// объявление объекта<br>
        &nbsp;&nbsp;&nbsp;&nbsp;obj1.who_i_am ();&nbsp;// вызов функции класса message<br>
        &nbsp;&nbsp;&nbsp;&nbsp;system(&quot;pause&quot;);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>
        }</p>
</div>
<div>
    <p>Объект</p>
</div>
<p>Объект&nbsp;&nbsp;— некоторая сущность в виртуальном пространстве, обладающая определённым состоянием и поведением,
    имеющая заданные значения свойств (атрибутов) и операций над ними (методов). Как правило, при рассмотрении объектов
    выделяется то, что объекты принадлежат одному или нескольким&nbsp;классам, которые определяют поведение (являются
    моделью) объекта. Термины «экземпляр класса» и «объект» взаимозаменяемы. <br>
    Каждый объект определяется с помощью&nbsp;класса.&nbsp;Класс описывает переменные, свойства, процедуры и события
    объекта.&nbsp;Объекты представляют собой экземпляры классов; после того как класс определен, можно создать любое
    количество объектов.<br>
    Хорошим примером связи между объектом и классом является форма для печенья и само печенье.&nbsp;Форма для печенья —
    это класс.&nbsp;Он определяет характеристики каждого печенья, например размер и форму.&nbsp;Класс используется для
    создания объектов.&nbsp;В нашем примере объект — это печенье.<br>
    Пример:  </p>

<div><br>
    // Создание экземпляра класса ArrayList с именем list<br>
    ArrayList list = new ArrayList();
</div>
<div>
    <p>Метод</p>
</div>
<p>Метод&nbsp;в&nbsp;(ООП)&nbsp;— это&nbsp;функция&nbsp;или&nbsp;процедура, принадлежащая какому-то&nbsp;классу&nbsp;или&nbsp;объекту
    и имеющая некоторое количество&nbsp;операторов&nbsp;для выполнения какого-то действия, а также набор&nbsp;входных
    аргументов&nbsp;и возвращаемое значение (могут отсутствовать).<br>
    Различают простые методы и статические методы (методы класса):</p>
<ul>
    <li>простые методы имеют доступ к данным объекта (конкретного экземпляра данного класса),</li>
    <li>статические методы не имеют доступа к данным объекта и для их использования не нужно создавать экземпляры
        (данного класса).
    </li>
</ul>
<p>Методы предоставляют интерфейс, при помощи которого осуществляется доступ к данным объекта некоторого класса, тем
    самым, обеспечивая инкапсуляцию данных.<br>
    В зависимости от того, какой уровень доступа предоставляет тот или иной метод, выделяют:</p>
<ul>
    <li>открытый (public) интерфейс — общий интерфейс для всех пользователей данного класса;</li>
    <li>защищённый (protected) интерфейс — внутренний интерфейс для всех наследников данного класса;</li>
    <li>закрытый (private) интерфейс — интерфейс, доступный только изнутри данного класса.</li>
</ul>
<p>Такое разделение интерфейсов позволяет сохранять неизменным открытый интерфейс, но изменять внутреннюю реализацию
    <br>
    Пример метода на Си++:</p>

<div><br>
    class Motorcycle<br>
    {<br>
    // доступ открыт всем, кто видит определение данного класса.<br>
    public void StartEngine() {/* Тело функции */ }
    <p>    /* доступ открыт самому классу (т.е. функциям-членам данного класса) и друзьям (friend) данного класса, как
        функциям, так и классам. */<br>
        protected void AddGas(int gallons) { /* Тело функции */ }</p>

    <p>        // доступ открыт классам, производным от данного.<br>
        private double GetTopSpeed{ /* Тело функции */ }</p>

    <p>}</p>
</div>
<p>Показательный пример:</p>

<div><br>
    class&nbsp;some {<br>
    &nbsp;&nbsp;&nbsp;friend&nbsp;void&nbsp;f(some&amp;); //дружественная функция<br>
    &nbsp;public:<br>
    &nbsp;&nbsp;&nbsp;int&nbsp;a_;<br>
    &nbsp;protected:<br>
    &nbsp;&nbsp;&nbsp;int&nbsp;b_;<br>
    &nbsp;private:<br>
    &nbsp;&nbsp;&nbsp;int&nbsp;c_;<br>
    &nbsp;};
    <p>&nbsp;void&nbsp;f(some&amp; obj) {<br>
        &nbsp;&nbsp; obj.a_ = 0;&nbsp;// ok     // доступ ко все переменным класса<br>
        &nbsp;&nbsp; obj.b_ = 0;&nbsp;// ok<br>
        &nbsp;&nbsp; obj.c_ = 0;&nbsp;// ok<br>
        &nbsp;}</p>

    <p>&nbsp;void&nbsp;g(some&amp; obj) {<br>
        &nbsp;&nbsp; obj.a_ = 0;&nbsp;// ok<br>
        &nbsp;&nbsp; obj.b_ = 0;&nbsp;/* CT error нет доступа т.к функция не принадлежит классу и не 
        дружественная*/<br>
        &nbsp;&nbsp; obj.c_ = 0;&nbsp;// CT error нет доступа т.к функция не принадлежит классу<br>
        &nbsp;}</p>

    <p>&nbsp;class&nbsp;derived :&nbsp;public&nbsp;some {<br>
        &nbsp; derived() {<br>
        &nbsp;&nbsp;&nbsp; a_ = 0;&nbsp;// ok    есть доступ т.к. a_  public<br>
        &nbsp;&nbsp;&nbsp;&nbsp; b_ = 0;&nbsp;// ok     есть доступ т.к. b_  protected а класс derived наследник some
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp; c_ = 0;&nbsp;// CT error   нет доступа т.к. с_ private<br>
        &nbsp;&nbsp; }<br>
        &nbsp;};</p>
</div>
<p>&nbsp;</p>
</div>
</body>
</html>
