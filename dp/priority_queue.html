<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>Очередь с приоритетом</title>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
    <script type="text/javascript" src="../syntax/sh_main.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_pascal.min.js"></script>
    <link type="text/css" rel="stylesheet" href="../style/sh_nedit.css">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});


    </script>
    <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>
<body onLoad="sh_highlightDocument();">

<div id="content">

    <h1>Очередь с приоритетом</h1>

    <h2>Двоичная куча</h2>

    <p><strong>Двоичная куча, пирамида, или сортирующее дерево</strong> - такое двоичное дерево, для которого выполнены
        три условия:</p>
    <ol>
        <li>Значение в любой вершине не меньше, чем значения её потомков (max-heap), или значение не больше, чем
            значения потомков (min-heap).
        </li>
        <li>Глубина листьев (расстояние до корня) отличается не более чем на 1 слой.</li>
        <li>Последний слой заполняется слева направо.</li>
    </ol>

    <p>В дальнейшем рассматриваются только max-heap. Все действия с min-heap осуществляются аналогично.</p>

    <p>Удобная структура данных для хранения сортирующего дерева - массив $A$, у которого первый элемент, $A_1$ - корень
        дерева, а потомками элемента $A_i$ являются $A_{2i}$ и $A_{2i+1}$.</p>

    <p>При нумерации элементов с нулевого (обычно в C/C++), корневой элемент - $A_0$, а потомки элемента $A_i$:
        $A_{2i+1}$ (левый) и $A_{2i+2}$ (правый). При таком способе хранения условия 2 и 3 выполнены автоматически. </p>

    <p>Высота кучи есть $\Theta \left( \log{N} \right)$, где $N$ — количество узлов дерева.</p>

    <h3>Операции</h3>
    <ol>
        <li>Добавить элемент в кучу. Сложность $O(\log{n})$</li>
        <li>Исключить максимальный элемент из кучи. Время работы $O(\log{n})$</li>
        <li>Изменить значение любого элемента. Время работы $O(\log{n})$</li>
    </ol>
    <p>На основе этих операций можно выполнять следующие действия:</p>

    <ol>
        <li>Превратить неупорядоченный массив элементов в кучу. Сложность $O(N)$</li>
        <li>Отсортировать массив путём превращения его в кучу, а кучи в отсортированный массив. Время работы
            $O(n\log{n})$
        </li>
    </ol>
    <p>Здесь $N$ - количество элементов кучи. Пространственная сложность - $O(1)$ для всех вышеперечисленных операций и
        действий.</p>

    <h3>Восстановление свойств кучи</h3>

    <p>Если в куче изменяется один из элементов, то она может перестать удовлетворять свойству упорядоченности. Для
        восстановления этого свойства служит процедура Heapify. Она восстанавливает свойство кучи в дереве, у которого
        левое и правое поддеревья удовлетворяют ему. Эта процедура принимает на вход массив элементов $A$ и индекс
        $i$.
        Она восстанавливает свойство упорядоченности во всём поддереве, корнем которого является элемент $A_i$.
        Если $i$-й элемент больше, чем его сыновья, всё поддерево уже является кучей, и делать ничего не надо. В
        противном случае меняем местами $i$-й элемент с наибольшим из его сыновей, после чего выполняем Heapify для
        этого сына.

        Процедура выполняется за время $O \left( \log{n} \right)$.
    <pre>
Heapify(A, i)
  left ← 2i
  right ← 2i+1
  heap_size - количество элементов в куче
  largest ← i
  if left ≤ A.heap_size и A[left] > A[i]
    then largest ← left
  if right ≤ A.heap_size и A[right] > A[largest]
    then largest ← right
  if largest ≠ i
    then Обменять A[i] ↔ A[largest]
         Heapify(A, largest)        </pre>

    <h3>Построение кучи - BuildHeap</h3>

    <p>Создание кучи из неупорядоченного массива входных данных. Время работы равно $O(n)$.</p>

<pre>
  BuildHeap(A)
    A.heap_size ← A.length
    for i ← ⌊A.length/2⌋ downto 1
      do Heapify(A, i)
</pre>

    <h3>Изменение значения элемента</h3>

<pre>
HeapIncreaseKey(A, i, key)
  if key < A[i]
    then error "Новый ключ меньше предыдущего"
  A[i] ← key
  while i > 1 и A[⌊i/2⌋] < A[i]
    do Обменять A[i] ↔ A[⌊i/2⌋]
      i ← ⌊i/2⌋
</pre>

    <h3>Добавление элемента - $O(\log{n})$</h3>

    <p>Добавление произвольного элемента в конец кучи, и восстановление свойства упорядоченности с помощью
        HeapIncreaseKey.</p>

<pre>
HeapInsert(A, key)
  A.heap_size ← A.heap_size+1
  A[A.heap_size] ← -∞
  HeapIncreaseKey(A, A.heap_size, key)
</pre>

    <h3>Удаление элемента - $O(\log{n})$</h3>

    <h2>Биномиальная куча</h2>

    <p><strong>Биномиальная куча (binomial heap)</strong> — структура данных, реализующая абстрактный тип данных
        «Очередь с приоритетом», которая представляет собой набор биномиальных деревьев с двумя свойствами:</p>
    <ol>
        <li>ключ каждой вершины не меньше ключа ее родителя;</li>
        <li>все биномиальные деревья имеют разный размер.</li>
    </ol>

    <p>Из этих свойств вытекают два следствия: Во-первых, корень каждого из деревьев имеет наименьший ключ среди его
        вершин. Во-вторых, суммарное количество вершин в биномиальной куче однозначно определяет размеры входящих в него
        деревьев. Например, биномиальная куча с $13=2^3+2^2+2^0$ вершинами состоит из трёх деревьев высотой 3, 2 и 0</p>

    <p>Следующие операции выполняются за время $O(\log{n})$, где $n$ — число вершин:</p>

    <ul>
        <li>Вставка нового элемента</li>
        <li>Нахождение элемента с минимальным ключом</li>
        <li>Удаление элемента с минимальным ключом</li>
        <li>Уменьшение значения ключа данного элемента</li>
        <li>Удаление данного элемента</li>
        <li>Объединение двух куч.</li>
    </ul>

    <h2>Фибоначчиева куча</h2>

    <p><strong>Фибоначчиева куча (Fibonacci heap)</strong> - структура данных, представляющая собой набор деревьев,
        упорядоченных в соответствии со свойством неубывающей пирамиды.</p>


    <table class=main>
        <thead>
        <tr>
            <th>Реализация</th>
            <th>Вставка</th>
            <th>Удаление элемента</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>Двоичная куча</td>
            <td>$O(\log{n})$</td>
            <td>$O(\log{n})$</td>
        </tr>
        <tr>
            <td>Биномиальная куча</td>
            <td>$O(\log{n})$</td>
            <td>$O(\log{n})$</td>
        </tr>
        <tr>
            <td>Фибоначчиева куча</td>
            <td>$O(1)$</td>
            <td>$O(\log{n})$</td>
        </tr>
        </tbody>
    </table>


</div>
</body>
</html>