<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>Многопоточное программирование</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
    <script type="text/javascript" src="../syntax/sh_main.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_xml.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_java.min.js"></script>
    <link type="text/css" rel="stylesheet" href="../style/sh_nedit.css">
</head>
<body onLoad="sh_highlightDocument()">
<div id="content">
<h1>Многопоточное программирование</h1>

<p>Обычно приложения с графическим интерфейсом исполняются в рамках одного потока. Если такое приложение начинает
    выполнять продолжительную по времени операцию, то возникает эффект "замораживания" интерфейса, который длится до
    тех пор, пока длительная операция не будет завершена. Один из вариантов решения этой проблемы - использование
    нескольких потоков (многопоточность).</p>

<p>Многопоточность незаменима тогда, когда необходимо, чтобы графический интерфейс продолжал отзываться на действия
    пользователя во время выполнения некоторой обработки информации. Например, поток, отвечающий за интерфейс, может
    ждать завершения другого потока, загружающего файл из интернета, и в это время выводить некоторую анимацию или
    обновлять прогресс-бар. Кроме того он может остановить поток загружающий файл, если будет нажата кнопка
    «отмена».</p>

<p>Еще одна популярная область применения многопоточности – игры. В игре различные потоки могут отвечать за работу с
    сетью, анимацию, расчет физики и т.п.</p>

<p><b>Многопоточность</b> - свойство платформы (например, операционной системы, виртуальной машины и т.д.) или
    приложения, состоящее в том, что процесс, порождённый в операционной системе, может состоять из нескольких
    потоков, выполняющихся «параллельно», то есть без предписанного порядка во времени. При выполнении некоторых
    задач такое разделение может помочь более эффективного использовать ресурсы вычислительной машины.</p>

<h3>API-функции Windows</h3>


<p>&nbsp;</p>

<h2>Демонстрация на Java</h2>

<p>Для демонстрации параллельной работы потоков  ниже приведена программа, в которой два потока спорят на предмет
    философского вопроса «что было раньше, яйцо или курица?». Главный поток уверен, что первой была курица, о чем он и
    будет сообщать каждую секунду. Второй же поток раз в секунду будет опровергать своего оппонента. Всего спор
    продлится 5 секунд. Победит тот поток, который последним изречет свой ответ на этот, без сомнения, животрепещущий
    философский вопрос.<br>
    Пример на Java</p>

<pre class="sh_java">
class EggVoice extends Thread {
  @Override
  public void run() {
    for(int i = 0; i &lt; 5; i++) {
      try{
        sleep(1000); // Приостанавливаем поток на 1 секунду
      }catch(InterruptedException e){ /* Ничего не делаем */ }
      System.out.println(&quot;яйцо!&quot;);
    } // Слово «яйцо» сказано 5 раз
  }
}
</pre>

<pre class="sh_java">
public class ChickenVoice //Класс с методом main()<br>
    {<br>
    static EggVoice mAnotherOpinion; //Побочный поток <br>
    public static void main(String[] args)<br>
    {<br>
    mAnotherOpinion = new EggVoice(); //Создание потока <br>
    System.out.println(&quot;Спор начат...&quot;);<br>
    mAnotherOpinion.start(); //Запуск потока <br>
    for(int i = 0; i &lt; 5; i++) {<br>
    try{<br>
    Thread.sleep(1000); //Приостанавливает поток на 1 секунду   }catch(InterruptedException e){}<br>
    System.out.println(&quot;курица!&quot;);<br>
    } //Слово «курица» сказано 5 раз<br>
    if(mAnotherOpinion.isAlive()) //Если оппонент еще не сказал последнее слово<br>
    {<br>
    try{<br>
    mAnotherOpinion.join(); //Подождать пока оппонент закончит высказываться.<br>
    }catch(InterruptedException e){}<br>
    System.out.println(&quot;Первым появилось яйцо!&quot;);<br>
    }<br>
    else //если оппонент уже закончил высказываться<br>
    {<br>
    System.out.println(&quot;Первой появилась курица!&quot;);<br>
    }<br>
    System.out.println(&quot;Спор закончен!&quot;);<br>
    }<br>
    }</p>
</pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>Консоль: <br>
    Спор начат...<br>
    курица! <br>
    яйцо! <br>
    яйцо! <br>
    курица! <br>
    яйцо! <br>
    курица! <br>
    яйцо! <br>
    курица! <br>
    яйцо! <br>
    курица! <br>
    Первой появилась курица! <br>
    Спор закончен!</p>

<p>&nbsp;</p>

<p>В приведенном примере два потока параллельно в течении 5 секунд выводят информацию на консоль. Точно предсказать,
    какой поток закончит высказываться последним, невозможно. Можно попытаться, и можно даже угадать, но есть большая
    вероятность того, что та же программа при следующем запуске будет иметь другого «победителя». Это происходит из-за
    так называемого «асинхронного выполнения кода». Асинхронность означает то, что нельзя утверждать, что какая-либо
    инструкция одного потока, выполнится раньше или позже инструкции другого. Или, другими словами, параллельные потоки
    независимы друг от друга, за исключением тех случаев, когда программист сам описывает зависимости между потоками с
    помощью предусмотренных для этого средств языка.</p>

<h2>Состояние гонки</h2>

<p>Состоя́ние го́нки&nbsp;(англ.&nbsp;race condition)&nbsp;— ошибка проектирования&nbsp;многопоточной&nbsp;системы или
    приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.<br>
    Пример:<br>
    int x;<br>
    // Поток 1:<br>
    while (!stop)<br>
    {<br>
    x++;<br>
    …<br>
    }<br>
    // Поток 2:<br>
    while (!stop)<br>
    {<br>
    if (x%2 == 0)<br>
    System.out.println(&quot;x=&quot; + x);<br>
    …<br>
    }</p>

<p>Пусть x=0. Предположим, что выполнение программы происходит в таком порядке:</p>
<ol>
    <li>if в потоке 2 проверяет&nbsp;x&nbsp;на чётность.</li>
    <li>Оператор «x++» в потоке 1 увеличивает&nbsp;x&nbsp;на единицу.</li>
    <li>Оператор вывода в потоке 2 выводит «x=1», хотя, казалось бы, переменная проверена на чётность.</li>
</ol>
<p>&nbsp;</p>

<h2>Способы решения</h2>

<p>Локальная копия<br>
    Самый простой способ решения&nbsp;— копирование&nbsp;переменной&nbsp;x&nbsp;в локальную переменную. Вот исправленный
    код:<br>
    // Поток 2:<br>
    while (!stop)<br>
    {<br>
    int cached_x = x;<br>
    if (cached_x%2 == 0)<br>
    System.out.println(&quot;x=&quot; + cached_x);<br>
    …<br>
    }</p>

<p>Естественно, этот способ работает только тогда, когда переменная одна и копирование производится за одну машинную
    команду.<br>
    Синхронизация<br>
    Более сложный, но и более универсальный метод решения&nbsp;—&nbsp;синхронизация&nbsp;потоков, а именно:<br>
    int x;<br>
    // Поток 1:<br>
    while (!stop)<br>
    {<br>
    synchronized(SomeObject)<br>
    {<br>
    x++;<br>
    }<br>
    …<br>
    }<br>
    // Поток 2:<br>
    while (!stop)<br>
    {<br>
    synchronized(SomeObject)<br>
    {<br>
    if (x%2 == 0)<br>
    System.out.println(&quot;x=&quot; + x);<br>
    }<br>
    …<br>
    }</p>

<p>Комбинированный способ<br>
    Предположим, что переменная&nbsp;x&nbsp;имеет тип не&nbsp;int, а&nbsp;long&nbsp;(на 32-битных ЭВМ её копирование
    выполняется за две машинных команды), а во втором потоке вместоSystem.out.println&nbsp;стоит более сложная
    обработка. В этом случае оба метода неудовлетворительны: первый&nbsp;— потому что&nbsp;x&nbsp;может измениться, пока
    идет копирование; второй&nbsp;— потому что засинхронизирован слишком большой объём кода.<br>
    Эти способы можно скомбинировать, копируя «опасные» переменные в синхронизированном блоке. С одной стороны, это
    снимет ограничение на одну машинную команду, с другой&nbsp;— позволит избавиться от слишком больших
    синхроблоков.<br>
    long x;<br>
    // Поток 1:<br>
    while (!stop)<br>
    {<br>
    synchronized(SomeObject)<br>
    {<br>
    x++;<br>
    }<br>
    …<br>
    }<br>
    // Поток 2:<br>
    while (!stop)<br>
    {<br>
    long cached_x;<br>
    synchronized (SomeObject)<br>
    {<br>
    cached_x = x;<br>
    }<br>
    if (cached_x%2 == 0)<br>
    //System.out.println(&quot;x=&quot; + cached_x);<br>
    DoSomethingComplicated(cached_x);<br>
    …<br>
    }<br>
    Очевидных способов выявления и исправления состояний гонки не существует. Лучший способ избавиться от гонок&nbsp;—
    правильное проектирование многозадачной системы.</p>

<p>&nbsp;</p>

<h2>Синхронизация потоков</h2>

<p>Добавить новый поток в программу несложно&nbsp;— намного сложнее организовать его выполнение и завершение, поэтому
    многие функции многопоточных API предназначены именно для синхронизации потоков. В этом разделе мы кратко рассмотрим
    такие средства синхронизации.<br>
    Потоки координируются с помощью&nbsp;событий&nbsp;(events), которые передают информацию о состоянии одного или
    нескольких потоков. Событие может быть&nbsp;установленным&nbsp;(signaled) или&nbsp;сброшенным(unsignaled).
    Конкретный смысл событий может быть разным, но обычно они сигнализируют о блокировке потока.<br>
    <a name="ix0016"></a>Блокировку потока можно представить себе в виде цикла, непрерывно опрашивающего некоторую
    логическую переменную. Цикл продолжается до тех пор, пока переменная не примет значение&nbsp;TRUE. С технической
    точки зрения это не совсем точно, потому что заблокированный поток не производит активных опросов события. Вместо
    этого он приостанавливается, а система удаляет его из списка активных потоков. Лишь после того как блокирующее
    событие перейдет в установленное состояние, выполнение потока возобновляется. Соответственно заблокированный поток
    почти не расходует процессорного времени. <br>
    Пример на С++(Добавить несколько потоков в приложение, написанное с использованием библиотеки Qt, очень просто. Для
    этого нужно лишь создать дочерний класс от&nbsp;QThread&nbsp;и перекрыть метод&nbsp;run().):</p>

<p>class Thread : public QThread  //унаследуемся от  QThread<br>
    { <br>
    public: <br>
    Thread();   <br>
    void setMessage(const QString &amp;message); <br>
    void run();      //побочный поток, кроме него еще имеется основной поток - в теле главной функции <br>
    void stop(); <br>
    <br>
    private: <br>
    QString messageStr; <br>
    volatile bool stopped; <br>
    };<br>
    Thread::Thread() <br>
    { <br>
    stopped = false; <br>
    }</p>

<p>void Thread::run() <br>
    { <br>
    while (!stopped)          //цикл пока не остановили поток<br>
    cerr &lt;&lt; messageStr.ascii(); <br>
    stopped = false; <br>
    cerr &lt;&lt; endl; <br>
    }<br>
    void Thread::stop()      //останавливаем поток <br>
    { <br>
    stopped = true; <br>
    }</p>

<p><a name="ix0046"></a>Блокировка потоков чаще всего используется для защиты совместных ресурсов от одновременного
    доступа со стороны нескольких потоков.<br>
    &nbsp;Мьютекс&nbsp;(mutex, сокращение от mutually exclusive, то есть «взаимоисключающий») представляет собой объект,
    который может в любой момент времени&nbsp;принадлежать&nbsp;лишь одному потоку, гарантируя безопасность доступа к
    связанному с ним ресурсу. Когда мьютекс принадлежит некоторому потоку, все остальные потоки, пытающиеся получить его
    в свое распоряжение, блокируются до освобождения мьютекса.<br>
    Пример на С++(Qt):<br>
    QMutex mutex;</p>

<p>void Thread::stop() <br>
    { <br>
    mutex.lock(); <br>
    stopped = true;  //значение переменной может изменить только1 поток одновременно<br>
    mutex.unlock(); <br>
    }</p>

<p><a name="ix0042"></a>Критические секции&nbsp;(critical section), как и мьютексы, используются для предотвращения
    одновременного доступа к ресурсу со стороны нескольких потоков. Однако если мьютекс может синхронизировать
    межпроцессные потоки, критическая секция ограничивается потоками одного процесса. Ограничение компенсируется
    скоростью&nbsp;— критическая секция работает быстрее, чем мьютекс.</p>

<p>Семафоры&nbsp;(semaphore) тоже могут применяться для ограничения доступа к ресурсам, но в отличие от мьютексов или
    критических секций семафор разрешает одновременный доступ со стороны нескольких потоков. Максимальное количество
    потоков, одновременно получающих доступ к ресурсу, определяется при создании семафора. Затем доступ предоставляется
    всем потокам до тех пор, пока их количество не достигнет заданного предела. Все остальные потоки, желающие получить
    доступ, блокируются до тех пор, пока один или несколько потоков не прекратят работу с ресурсом.<br>
    Семафор&nbsp;— это объект, с которым можно выполнить три операции.<br>
    init(n):<br>
    счётчик := n<br>
    <br>
    enter():<br>
    ждать пока счётчик станет больше 0; после этого уменьшить счётчик на единицу.<br>
    <br>
    leave():<br>
    увеличить счётчик на единицу.</p>

<p>Предположим, что есть такой участок кода:<br>
    semaphore.init(5);<br>
    .....<br>
    .....<br>
    void DoSomething( void )<br>
    {<br>
    semaphore.enter();<br>
    .......<br>
    semaphore.leave();<br>
    }<br>
    Тогда не более пяти потоков могут одновременно выполнять функцию&nbsp;DoSomething().</p>
</div>
</body>
</html>
