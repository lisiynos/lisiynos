<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>MockObjects</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
</head>
<body>
<div id="content">
    <h1>MockObjects - объекты-заглушки и их использование </h1>

    <h3>Цели:</h3>

    <p>Любой человек, начинающий изучать юнит тестирование рано или поздно сталкивается со следующей проблемой: согласно
        идеологии юнит тестирования каждый класс должен быть протестирован отдельно. В простых книжных примерах это
        выглядит легко, но на практике между многими классами имеется тесная взаимосвязь. Для разрыва такой связи как
        раз и может служить Mock. А для облегчения тестирования используются библиотеки — библиотеки, создающие
        объекты-заглушки.</p>

    <p> MockObjects - это автоматически генерируемые заглушки, которые позволяют имитировать некоторую функциональность
        и управлять ею прямо из теста. MockObjects (мок) создаются на базе какого-то интерфейса или класса. В этом
        случае мок поддерживает все методы эмулируемого интерфейса, плюс методы по настройке поведения мока.</p>

    <p><strong><em>Управление MockObjects включает:</em></strong></p>
    <ul>
        <li>возврат определенных значений из методов при наступлении определенных условий;</li>
        <li>ожидание определенных выводов методов, определенное количество раз;</li>
        <li>учет порядка вызовов методов.</li>
    </ul>
    <p>Преимущество разработки с Mock-объектами заключается в том, что они позволяют уже на ранних этапах разрабатывать
        программное обеспечение, имея на руках только интерфейсы, но не имея реальные классы. MockObjects также
        позволяют заметно ускорить исполнение тестов, изолируя ресурсоемкие участки кода. Однако не стоит забывать, что
        нельзя слишком увлекаться MockObjects, т.к. это может привести к неадекватности тестов и реализации.</p>

    <p><strong><em>Когда использовать Mock Objects</em></strong><br>
        Мнимые объекты или моки (Mock Objects) используются:</p>
    <ul>
        <li>для изоляции тестируемого кода,</li>
        <li>для тестирования делегирования.</li>
    </ul>
    <p>При использовании Mock Objects для изоляции они заменяют реальные объекты, используемые в тестируемом коде. При
        этом в тесте появляется возможность контролировать используемые внутри тестируемого кода (делегируемые) объекты,
        а именно указывать, какой результат они должны возвращать при вызове тех или иных методов с теми или иными
        параметрами.</p>

    <p> При использовании Mock Objects для тестирования делегирования мы можем генерировать ожидания тех или иных
        вызовов в результате работы тестируемого кода. Если эти вызовы не будут совершены, Mock Objects сгенерируют
        ошибки.</p>

    <p><strong><em>Причины необходимости использования мок-объектов вместо реальных классов:</em></strong></p>
    <ul>
        <li>Тесты выполняются слишком медленно. Медленный тест - это&nbsp;<a
                href="http://wiki.agiledev.ru/doku.php?id=tdd:smells" title="tdd:smells">запах</a>. Обычно это связано с
            использованием внешних, не слишком быстрых ресурсов.
        </li>
        <li>Тесты зависят от внешних ресурсов, которые вы не всегда можете контролировать.</li>
        <li>Тестирование при помощи реальных классов не может быть осуществлено принципиально, например, если у вас еще
            их нет, а их подготовкой занимаются другие разработчики.
        </li>
        <li>При необходимости тестирования поведения при исключительных ситуациях, в случаях, когда генерация исключений
            потребует больших усилий. Дать здесь ссылку на статью про ручное создание мок-объектов.
        </li>
        <li>При необходимости проверки правильности взаимодействия тестируемого объекта с другими объектами, в случаях,
            когда это взаимодействие составляет суть работы класса. Например, при проверке правильности кеширования
            информации, нам требуется удостовериться, что информация будет затребована из источника именно 1 раз.
        </li>
    </ul>
    <p><strong>Фреймворки, которые поддерживают Mock Objects</strong><br>
        Для&nbsp;PHP&nbsp;мок-объекты поддерживаются SimpleTest, а также PHPUnit2.<br>
        Для .Net мок-объекты поддерживаются Nunit, Visual Studio Team System, MbUnit, Mногофункциональным Mock
        Фреймворком является Typemock Isolator, также одним из лидирующих и не менее функциональным является Rhino Mock.
    </p>

    <h3><a name="передача_зависимого_объекта_через_констр">Передача зависимого объекта через конструктор. Constructor
        Injection</a></h3>

    <p>Constructor injection - самый распространенный вид внедрения зависимостей и самый простой. Большинство
        ознакомительных примеров по использованию мок-объектов используют именно этот способ передачи моков в
        тестируемые классы. Действительно, все наглядно и просто: создаем мок-объект, передаем его в конструктор - и
        все, мы изолировали класс. Класс становится менее связанным, увеличивается гибкость, все довольны:</p>
    <table border="1" cellspacing="0" cellpadding="0">
        <tr>
            <td width="638" valign="top"><br>
                class SomeClass()<br>
                {<br>
                protected $_delegated_object;
                <p>  public function __construct(InterfaceA $delegated_object){<br>
                    $this-&gt;_delegated_object = $delegated_object; <br>
                    }</p>

                <p>  public function someMethodToBeTested(){<br>
                    [...some code collecting $params...]<br>
                    $this-&gt;_delegated_object-&gt;doSomething($params);<br>
                    [..any other code...]<br>
                    }<br>
                    }</p></td>
        </tr>
    </table>
    <p>&nbsp;</p>

    <p>Пример теста:</p>
    <table border="1" cellspacing="0" cellpadding="0">
        <tr>
            <td width="638" valign="top"><br>
                Mock::generate('InterfaceA', 'MockDelegatedClass');
                <p>class SomeClassTest extends TestCase{</p>

                <p>  function testSomeMethodToBeTested() {<br>
                    $delegated_object = new MockDelegatedClass();<br>
                    $params = <a href="http://www.php.net/array">array</a>('some expected params');<br>
                    $delegated_object-&gt;expectOnce('doSomething', <a href="http://www.php.net/array">array</a>($params));
                </p>

                <p>    // Passing delegated object in tested class constructor<br>
                    $some_class = new SomeClass($delegated_object); <br>
                    $some_class-&gt;someMethodToBeTested();<br>
                    }<br>
                    }</p></td>
        </tr>
    </table>
    <p>&nbsp;</p>

    <p>Еще одно достоинство Constructor injection заключается в том, что все зависимости класса прописываются явно. То
        есть, взглянув на один лишь конструктор класса, мы уже понимаем, какими ресурсами остальной системы он пользует.
        Это несомненно плюс на этапе изучения системы. </p>
</div>
</body>
</html>
