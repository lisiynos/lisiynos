<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>Объектно-ориентированное программирование (ООП, OOP)</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
    <script type="text/javascript" src="../syntax/sh_main.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_cpp.min.js"></script>
    <link type="text/css" rel="stylesheet" href="../style/sh_nedit.css">
</head>
<body>
<div id="content">
    <h1>Объектно-ориентированное программирование (ООП, OOP)</h1>

    <p>Парадигма программирования, в которой основные концепции: <strong>объект</strong> и <strong>класс</strong>.</p>

    <p><strong>Класс</strong> - является описанием ещё не существующей сущности (объекта). Фактически он описывает
        устройство объекта, являясь своего рода &quot;чертежом&quot;. Обычно классы разрабатывают таким образом, чтобы
        их объекты
        соответствовали объектам предметной области. </p>

    <p><strong></strong><strong>Объект</strong> - сущность, которой можно посылать сообщения, и которая может на них
        реагировать,
        используя свои данные. <strong>Объект</strong> - экземпляр класса. Данные объекта скрыты от остальной программы.
        Сокрытие данных
        называется <strong>инкапсуляцией</strong>.</p>

    <p><strong>Объект</strong> - экземпляр класса, сущность в адресном пространстве вычислительной системы, появляющаяся
        при создании экземпляра класса или копирования прототипа. </p>

    <p><strong></strong><strong>Абстрагирование</strong> - выделение набора значимых характеристик объекта, исключая из
        рассмотрения
        незначимые. </p>

    <p><strong>Абстракция</strong> - набор всех характеристик объекта, значимых с точки зрения решаемых задач. </p>

    <p><strong>Инкапсуляция</strong> - свойство системы, позволяющее объединить данные и методы, работающие с ними в
        <strong>классе</strong>, и скрыть детали реализации от пользователя. </p>

    <p><strong>Наследование</strong> - свойство системы, позволяющее описать новый класс на основе уже существующего с
        частично или полностью заимствующейся функциональностью (данными и методами). Класс, от которого производится
        наследование, называется <strong>базовым</strong>, <strong>родительским</strong> или
        <strong>суперклассом</strong>. Новый класс - <strong>потомком</strong>, <strong>наследником</strong> или
        <strong>производным</strong> классом.</p>

    <p><strong>Полиморфизм</strong> - свойство системы использовать объекты с одинаковым интерфейсом без информации о
        типе и внутренней структуре объекта. </p>

    <p><strong>Прототип</strong> - объект-образец, по образу и подобию которого создаются другие объекты. Объекты-копии
        могут сохранять связь с родительским объектом, автоматически наследуя изменения в прототипе; эта особенность
        определяется в рамках конкретного языка. В
        языках с прототипированием (например, JavaScript) вместо классов используются <strong>объекты-прототипы</strong>.
    </p>

    <p align="center"><strong>Объектно-ориентированное программирование</strong></p>

    <p>Концепция объектно-ориентированного программирования подразумевает, что основой управления процессом реализации
        программы является передача сообщений объектам. Поэтому объекты должны определяться совместно с сообщениями, на
        которые они должны реагировать при выполнении программы. В этом состоит главное отличие ООП от процедурного
        программирования, где отдельно определённые структуры данных передаются в процедуры (функции) в качестве
        параметров. Таким образом, объектно-ориентированная программа состоит из объектов – отдельных фрагментов кода,
        обрабатывающего данные, которые взаимодействуют друг с другом через определённые интерфейсы.<br>
        Объектно-ориентированный язык программирования должен обладать следующими свойствами:</p>
    <ol>
        <li><strong>абстракции</strong> – модель, содержащая качества (свойства) предмета получается путем мысленного
            удаления его частей значимых с точки зрения решаемой задачи;
        </li>
        <li><strong>инкапсуляции</strong> – механизма, связывающего вместе код и данные, которыми он манипулирует, и
            защищающего их от внешних помех и некорректного использования;
        </li>
        <li><strong>наследования</strong> – процесса, с помощью которого один объект приобретает свойства другого, т.е.
            поддерживается иерахия объектов;
        </li>
        <li><strong>полиморфизма</strong> – свойства, позволяющего использовать один и тот же интерфейс для общего
            класса действий.
        </li>
    </ol>
    <p> Разработка объектно-ориентированных программ состоит из следующих последовательных работ:<br>
        - определение основных объектов, необходимых для решения данной задачи;<br>
        - определение закрытых данных (данных состояния) для выбранных объектов;<br>
        - определение второстепенных объектов и их закрытых данных;<br>
        - определение иерархической системы классов, представляющих выбранные объекты;<br>
        - определение ключевых сообщений, которые должны обрабатывать объекты каждого класса;<br>
        - разработка последовательности выражений, которые позволяют решить поставленную задачу;<br>
        - разработка методов, обрабатывающих каждое сообщение;<br>
        - очистка проекта, то есть устранение всех вспомогательных промежуточных материалов, использовавшихся при
        проектировании;<br>
        - кодирование, отладка, компоновка и тестирование.<br>
        Объектно-ориентированное программирование позволяет программисту моделировать объекты определённой предметной
        области путем программирования их содержания и поведения в пределах класса. Конструкция «класс» обеспечивает
        механизм инкапсуляции для реализации абстрактных типов данных.<br>
        Инкапсуляция как бы скрывает и подробности внутренней реализации типов, и внешние операции и функции, допустимые
        для выполнения над объектами этого типа.</p>

    <p><strong>&nbsp;</strong><strong>1. Что такое объектно-ориентированное программирование</strong></p>

    <p>Элементы объектно-ориентированного программирования (ООП) появились в начале 70-х годов в языке моделирования
        Симула, затем получили свое развитие, и в настоящее время ООП принадлежит к числу ведущих технологий
        программирования.</p>

    <p> Основная цель ООП, как и большинства других подходов к программированию – повышение эффективности разработки
        программ. Идеи ООП оказались плодотворными и нашли применение не только в языках программирования, но и в других
        областях Computer Science, например, в области разработки операционных систем.<br>
        Появление ООП было связано с тем наблюдением, что компьютерные программы представляют собой описание действий,
        выполняемых над различными объектами. В роли последних могут выступать, например, графические объекты, записи в
        базах данных или совокупности числовых значений. В традиционных методах программирования изменение данных или
        правил и методов обработки часто приводило к необходимости значительного изменения программы. Всякое
        существенное изменения программы – это большая неприятность для программиста, так как при этом увеличивается
        вероятность ошибок, вследствие чего возрастает время, необходимое для «доводки» программы. Использование ООП
        позволяет выйти из такой ситуации с минимальными потерями, сводя необходимую модификацию программы к её
        расширению и дополнению. Необходимо заметить, что ООП не является панацеей от всех программистских бед, но его
        ценность как передовой технологии программирования несомненна. Изучение идей и методов ООП может существенно
        упростить разработку и отладку сложных программ.</p>

    <p> Мы уже привыкли использовать в своих программах процедуры и функции для программирования тех сложных действий по
        обработке данных, которые приходится выполнять многократно. Использование подпрограмм в своё время было важным
        шагом на пути к увеличению эффективности программирования.<br>
        Подпрограмма может иметь формальные предметы, которые при обращении к ней заменяются фактическими предметами. В
        этом случае есть опасность вызова подпрограммы с неправильными данными, что может привести к сбою программы и её
        аварийному завершению при выполнении. Поэтому естественным обобщением традиционного подхода к программированию
        является объединение данных и подпрограмм (процедур и функций), предназначенных для их обработки.</p>

    <p><strong>2. Объекты</strong></p>

    <p>Базовым в объектно-ориентированном программировании является понятие объекта. Объект имеет определённые свойства.
        Состояние объекта задаётся значениями его признаков. Объект «знает», как решать определённые задачи, то есть
        располагает методами решения. Программа, написанная с использованием ООП, состоит из объектов, которые могут
        взаимодействовать между собой.<br>
        Ранее отмечалось, что программная реализация объекта представляет собой объединение данных и процедур их
        обработки. Переменные объектного типа называют экземплярами объекта. Здесь требуется уточнение – экземпляр можно
        лишь формально назвать переменной. Его описание даётся в предложение описания переменных, но в действительности
        экземпляр – нечто большее, чем обычная переменная.<br>
        В отличие от типа «запись», объектный тип содержит не только поля, описывающие данные, но также процедуры и
        функции, описания которых содержится в описании объекта. Эти процедуры и функции называют методами.<br>
        Методам объекта доступны его поля. Следует отметить, что методы и их параметры определяются в описании объекта,
        а их реализация даётся вне этого описания, в том мест программы, которое предшествует вызову данного метода.<br>
        В описании объекта фактически содержаться лишь шаблоны обращения к методам, которые необходимы компилятору для
        проверки соответствия количества параметров и их типов при обращении к методам. Вот пример описания объекта[1]:
    </p>

    <p>Type<br>
        Location = object<br>
        X,Y: Integer;<br>
        Procedure Init(InitX, InitY: Integer);<br>
        Function GetX: Integer;<br>
        Function GetY: Integer;<br>
        End;</p>

    <p>Здесь описывается объект, который может использоваться в дальнейшем, скажем, в графическом режиме и который
        предназначен для определения положения на экране произвольного графического элемента. Объект описывается с
        помощью зарезервированных слов object…end, между которыми находиться описание полей и методов. В нашем примере
        объект содержит два поля для хранения значений графических координат, а так же для описания процедуры и двух
        функций - это методы данного объекта. Процедура предназначена для задания первоначального положения объекта, а
        функция – для считывания его координат.</p>

    <p><strong>3. Инкапсуляция</strong></p>

    <p>Инкапсуляция является важнейшим свойством объектов, на котором строится объектно-ориентированное
        программирование. Инкапсуляция заключается в том, что объект скрывает в себе детали, которые несущественны для
        использования объекта. В традиционном подходе к программированию с использованием глобальных переменных
        программист не был застрахован от ошибок, связанных с использованием процедур, не предназначенных для обработки
        данных, связанных с этими переменными. Предположим, например, что имеется «не-ООП» программа, предназначенная
        для начисления заработной платы сотрудникам некой организации, а в программе имеются два массива. Один массив
        хранит величину заработной платы, а другой – телефонные номера сотрудников (для составления отчёта для налоговой
        инспекции). Что произойдёт, если программист случайно перепутает эти массивы? Очевидно, для бухгалтерии начнутся
        тяжёлые времена. «Жёсткое» связание данных и процедур их обработки в одном объекте позволит избежать
        неприятностей такого рода.<br>
        Инкапсуляция и является средством организации доступа к данным только через соответствующие методы.<br>
        В нашем примере описание объекта процедура инициализации Init и функции GetX и GetY уже не существуют как
        отдельные самостоятельные объекты. Это неотъемлемые части объектного типа Location. Если в программе имеется
        описание нескольких переменных указанного типа, то для каждой переменной резервируется своя собственная область
        памяти для хранения данных, а указатели на точки входа в процедуру и функции – общие. Вызов каждого метода
        возможен только с помощью составного имени, явно указывающего, для обработки каких данных предназначен данный
        метод.</p>

    <p><strong>4. Наследование</strong></p>

    <p>Наследование – это ещё одно базовое понятие объектно-ориентированного программирования. Наследование позволяет
        определять новые объекты, используя свойства прежних, дополняя или изменяя их. Объект-наследник получает все
        поля и методы «родителя», к которым он может добавить свои собственные поля и методы или заменить («перекрыть»)
        их своими методами.<br>
        Пример описания объекта-наследника даётся ниже:</p>

    <p>Tipe<br>
        Point = object(Location)<br>
        Visible: Boolean;<br>
        Procedure Int(IntX, IntY: Integer);<br>
        Procedure Show;<br>
        Procedure Hide;<br>
        Function IsVisible: Boolean;<br>
        Procedure MoveTo(NewX, NewY: Integer);<br>
        End;</p>

    <p>Наследником здесь является объект Point, описывающий графическую точку, а родителем – объект Location. Наследник
        не содержит описание полей и методов родителя. Имя последнего указывается в круглых скобках после слова object.
        Из методов наследника можно вызывать методы родителя. Для создания наследника не требуется иметь исходный текст
        объекта родителя.<br>
        Объект-родитель может быть уже в составе оттранслированного модуля.<br>
        В чём привлекательность наследования? Если некий объект был уже определён и отлажен, он может быть использован и
        в других программах. При этом может оказаться, что новая задача отличается от предыдущей, и возникает
        необходимость некоторой модификации как данных, так и методов их обработки. Программисту приходится решать
        дилемму – создания объектов заново или использовать результаты предыдущей работы, применяя механизм
        наследования. Первый путь менее эффективен, так как требует дополнительных затрат времени на отладку и
        тестирование. Во втором случае часть этой работы оказывается выполненной, что сокращает время на разработку
        новой программы. Программист при этом может и не знать деталей реализации объекта- родителя.<br>
        В нашем примере к объекту, связанному с определением положения графического элемента, просто добавилось новое
        поле, описывающее признак видимости графической точки, и несколько новых методов, связанных с режимом
        отображения точки и её преобразованиями.</p>

    <p><strong>5. Виртуальные методы</strong></p>

    <p>Наследование позволяет создавать иерархические, связанные отношениями подчинения, структуры данных. Следует,
        однако, заметить, что при использовании этой возможности могут возникнуть проблемы. Предположим, что в нашей
        графической программе необходимо определить объект Circle, который является потомком другого объекта Point:</p>

    <p>Type<br>
        Circle = object (point)<br>
        Radius: Integer;<br>
        Procedure Show;<br>
        Procedure Hide;<br>
        Procedure Expand(ExpandBy: Integer);<br>
        Procedure Contact(ContactBy: Integer);<br>
        End;</p>

    <p>Новый объект Circle соответствует окружности. Поскольку свойства окружности отличаются от свойств точки, в
        объекте-наследнике придется изменять процедуры Show и Hide, которые отображают окружность и удаляют её
        изображение с экрана. Может оказаться, что метод Init (см. предыдущий пример) объекта Circle, унаследованный от
        объекта Point, также использует методы Show и Hide, впредь во время трансляции объекта Point использует ссылки
        на старые методы. Очевидно в объекте Circle они работать не будут.<br>
        Можно, конечно, попытаться «перекрыть» метод Init. Чтобы это сделать, нам придётся полностью воспроизвести текст
        метода. Это усложни работу, да и не всегда возможно, поскольку исходного текста программы может не оказаться под
        рукой (если объект-родитель уже находиться в оттранслированном модуле).<br>
        Для решения этой проблемы используется виртуальный метод. Связь между виртуальным методом и вызывающими их
        процедурами устанавливается не во время трансляции (это называется ранним связанием), а во время выполнения
        программы (позднее связание.<br>
        Чтобы использовать виртуальный метод, необходимо в описании объекта после заголовка метода добавить ключевое
        слово virtual. Заголовки виртуальных методов родителя и наследника должны в точности совпадать.<br>
        Инициализация экземпляра объекта, имеющего виртуальные методы, должна выполняться с помощью специального метода
        – конструктора. Конструктор обычно присваивает полям объекта начальные значения и выполняет другие действия по
        инициализации объекта. В заголовке метода-конструктора слово procedure заменяется словом constructor. Действия
        обратные действиям конструктора, выполняет ещё один специальный метод – деструктор. Он описывается словом
        destructor.<br>
        Конструктор выполняет действия по подготовке позднего связывания. Эти действия заключаются в создании указателя
        на таблицу виртуальных методов, которая в дальнейшем используется для поиска методов. Таблица содержит адреса
        всех виртуальных методов. При вызове виртуального метода по его имени определяется адрес, а затем по этому
        адресу передается управление.<br>
        У каждого объектного типа имеется своя собственная таблица виртуальных методов, что позволяет одному и тому же
        оператору вызывать разные процедуры. Если имеется несколько экземпляров объектов одного типа, то недостаточно
        вызвать конструктор для одного из них, а затем просто скопировать этот экземпляр во все остальные. Каждый объект
        должен иметь свой собственный конструктор, который вызывается для каждого экземпляра. В противном случае
        возможен сбой в работе программы.<br>
        Заметим, что конструктор или деструктор, могут быть «пустыми», то есть не содержать операторов. Весь необходимый
        код в этом случае создается при трансляции ключевых слов construct и destruct.</p>

    <p><strong>6. Динамическое создание объектов</strong></p>

    <p>Переменные объектного типа могут быть динамическими, то есть размещаться в памяти только во время их
        использования. Для работы с динамическими объектами используются расширенный синтаксис процедур New и Dispose.
        Обе процедуры в этом случае содержат в качестве второго параметра вызов конструктора или деструктора для
        выделения или освобождения памяти переменной объектного типа:</p>

    <p>New(P, Construct) или <br>
        Dispose(P, Destruct)</p>

    <p>Где P – указатель на переменную объектного типа, а Construct или Destruct – конструктор и деструктор этого
        типа.<br>
        Действие процедуры New в случае расширенного синтаксиса равносильно действию следующей пары операторов:</p>

    <p>New(P);<br>
        P^.Construct;</p>

    <p>Эквивалентом Dispose является следующее:</p>
    <br clear="all">

    <p>P^Dispose;<br>
        Dispose(P)</p>

    <p>Применение расширенного синтаксиса не только улучшает читаемость исходного кода, но и генерирует более короткий и
        эффективный исполняемый код.</p>

    <p><strong>7. Полиморфизм</strong></p>

    <p>Полиморфизм заключается в том, что одно и то же имя может соответствовать различным действиям в зависимости от
        типа объекта. В тех примерах, которые рассматривались ранее, полиморфизм проявлялся в том, что метод Init
        действовал по-разному в зависимости от того, является объект точкой или окружностью. Полиморфизм напрямую связан
        с механизмом позднего связывания. Решение о том, какая операция должна быть выполнена в конкретной ситуации,
        принимается во время выполнения программы.<br>
        Следующий вопрос, связанный с использованием объектов, заключается в совместимости объектных типов. Полезно
        знать следующее. Наследник сохраняет свойства совместимости с другими объектами своего родителя. В правой части
        оператора присваивания вместо типов родителя можно использовать типы наследника, но не наоборот. Таким образом,
        в нашем примере допустимы присваивания:<br>
        объектный ориентированный язык программирование</p>
    <br clear="all">

    <p>Var<br>
        Alocation : Location;<br>
        Apoin : Point;<br>
        Acircle : Circle;<br>
        Alocation :=Apoint<br>
        Apoint := Acrcle;<br>
        Alocation := Acircle;</p>

    <p>Дело в том, что наследник может быть более сложным объектом, содержащим поля и методы, поэтому присваиваемые
        значения экземпляра объекта- родителя экземпляру объекта-наследника может оставить некоторые поля
        неопределёнными и, следовательно, представляет потенциальную опасность. При выполнении оператора присвоения
        копируются только те поля данных, которые являются общими для обоих типов.</p>
</div>
</body>
</html>
