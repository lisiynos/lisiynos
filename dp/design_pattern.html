<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>Шаблоны проектирования</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
    <script type="text/javascript" src="../syntax/sh_main.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_xml.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_cpp.min.js"></script>
    <link type="text/css" rel="stylesheet" href="../style/sh_nedit.css">
</head>
<body onLoad="sh_highlightDocument()">
<div id="content">
    <h1>Шаблоны проектирования</h1>

    <p>В разработке программного обеспечения, шаблон проектирования или паттерн (<strong>design pattern</strong>) —
        повторимая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого
        часто возникающего контекста.</p>

    <h2>История</h2>

    <p>В 1970-е годы архитектор Кристофер Александр составил набор шаблонов проектирования. В области архитектуры эта
        идея не получила такого развития, как позже в области программной разработки.</p>

    <p>В 1987 году Кент Бэк (Kent Beck) и Вард Каннингем (Ward Cunningham) взяли идеи Александра и разработали шаблоны
        применительно к разработке программного обеспечения для разработки графических оболочек на языке Smalltalk.</p>

    <p>В 1988 году Эрих Гамма (Erich Gamma) начал писать докторскую диссертацию при цюрихском университете об общей
        переносимости этой методики на разработку программ.</p>

    <p>В 1989—1991 годах Джеймс Коплин (James Coplien) трудился над разработкой идиом для программирования на C++ и
        опубликовал в 1991 году книгу Advanced C++ Idioms.</p>

    <p>В этом же году Эрих Гамма заканчивает свою докторскую диссертацию и переезжает в США, где в сотрудничестве с
        Ричардом Хелмом (Richard Helm), Ральфом Джонсоном (Ralph Johnson) и Джоном Влиссидсом (John Vlissides) публикует
        книгу Design Patterns — Elements of Reusable Object-Oriented Software. В этой книге описаны 23 шаблона
        проектирования. Также команда авторов этой книги известна общественности под названием «Банда четырёх» (<strong>Gang
            of Four</strong>, часто сокращается до <strong>GoF</strong>). Именно эта книга стала причиной роста
        популярности шаблонов проектирования.</p>

    <h2>Польза</h2>

    <p>Главная польза каждого отдельного шаблона состоит в том, что он описывает решение целого класса абстрактных
        проблем. Также тот факт, что каждый шаблон имеет свое имя, облегчает дискуссию об абстрактных структурах данных
        (ADT) между разработчиками, так как они могут ссылаться на известные шаблоны. Таким образом, за счёт шаблонов
        производится унификация терминологии, названий модулей и элементов проекта.</p>

    <p>Правильно сформулированный шаблон проектирования позволяет, отыскав удачное решение, пользоваться им снова и
        снова. </p>

    <p align="center"><strong>Основные типы шаблонов проектирования</strong></p>
    <table border="1" cellspacing="0" cellpadding="0">
    <tr>
        <td><br>
            <strong>Название</strong></td>
        <td><p align="center"><strong>Оригинальное название</strong></p></td>
        <td><p align="center"><strong>Описание</strong></p></td>
    </tr>
    <tr>
        <td width="630" colspan="3"><p><strong>Основные шаблоны (Fundamental)</strong></p></td>
    </tr>
    <tr>
        <td><p>Шаблон делегирования </p></td>
        <td><p>Delegation pattern </p></td>
        <td><p>Объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого
            поведения связанному объекту.</p></td>
    </tr>
    <tr>
        <td><p>Шаблон функционального дизайна </p></td>
        <td><p>Functional design </p></td>
        <td><p>Гарантирует, что каждый модуль компьютерной программы имеет только одну обязанность и исполняет её с
            минимумом побочных эффектов на другие части программы.</p></td>
    </tr>
    <tr>
        <td><p>Неизменяемый интерфейс</p></td>
        <td><p>Immutable interface </p></td>
        <td><p>Создание&nbsp;неизменяемого объекта.</p></td>
    </tr>
    <tr>
        <td><p>Интерфейс </p></td>
        <td><p>Interface </p></td>
        <td><p>Общий метод для структурирования компьютерных программ для того, чтобы их было проще понять.</p></td>
    </tr>
    <tr>
        <td><p>Интерфейс-маркер </p></td>
        <td><p>Marker interface </p></td>
        <td><p>В качестве атрибута (как пометки объектной сущности) применяется наличие или отсутствие реализации
            интерфейса-маркера. В современных языках программирования вместо этого могут применяться атрибуты или
            аннотации.</p></td>
    </tr>
    <tr>
        <td><p>Контейнер свойств </p></td>
        <td><p>Property Container</p></td>
        <td><p>Позволяет добавлять дополнительные свойства для класса в контейнер (внутри класса), вместо расширения
            класса новыми свойствами.</p></td>
    </tr>
    <tr>
        <td><p>Event Channel </p></td>
        <td><p>Event Channel</p></td>
        <td><p>Расширяет шаблон Publish/Subscribe, создавая централизованный канал для событий. Использует
            объект-представитель для подписки и объект-представитель для публикации события в канале. Представитель
            существует отдельно от реального издателя или подписчика. Подписчик может получать опубликованные события от
            более чем одного объекта, даже если он зарегистрирован только на одном канале.</p></td>
    </tr>
    <tr>
        <td width="630" colspan="3"><p><strong>Порождающие
            шаблоны&nbsp;</strong><strong>(</strong><strong>Creational</strong><strong>)</strong>&nbsp;— шаблоны
            проектирования, которые абстрагируют процесс инстанцирования. Они позволяют сделать систему независимой от
            способа создания, композиции и представления объектов. Шаблон, порождающий классы, использует наследование,
            чтобы изменять инстанцируемый класс, а шаблон, порождающий объекты, делегирует инстанцирование другому
            объекту.</p></td>
    </tr>
    <tr>
        <td><p>Абстрактная фабрика </p></td>
        <td><p>Abstract factory </p></td>
        <td><p>Класс, который представляет собой интерфейс для создания компонентов системы.</p></td>
    </tr>
    <tr>
        <td><p>Строитель </p></td>
        <td><p>Builder </p></td>
        <td><p>Класс, который представляет собой интерфейс для создания сложного объекта.</p></td>
    </tr>
    <tr>
        <td><p>Фабричный метод </p></td>
        <td><p>Factory method </p></td>
        <td><p>Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс
            инстанцировать.</p></td>
    </tr>
    <tr>
        <td><p>Отложенная инициализация </p></td>
        <td><p>Lazy initialization </p></td>
        <td><p>Объект, инициализируемый во время первого обращения к нему.</p></td>
    </tr>
    <tr>
        <td><p>Пул одиночек </p></td>
        <td><p>Multiton </p></td>
        <td><p>Гарантирует, что класс имеет поименованные экземпляры объекта и обеспечивает глобальную точку доступа к
            ним.</p></td>
    </tr>
    <tr>
        <td><p>Объектный пул </p></td>
        <td><p>Object pool </p></td>
        <td><p>Класс, который представляет собой интерфейс для работы с набором инициализированных и готовых к
            использованию объектов.</p></td>
    </tr>
    <tr>
        <td><p>Прототип </p></td>
        <td><p>Prototype </p></td>
        <td><p>Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через
            конструктор.</p></td>
    </tr>
    <tr>
        <td><p>Получение ресурса есть инициализация </p></td>
        <td><p>Resource acquisition is initialization (RAII) </p></td>
        <td><p>Получение некоторого ресурса совмещается с инициализацией, а освобождение&nbsp;— с уничтожением
            объекта.</p></td>
    </tr>
    <tr>
        <td><p>Одиночка </p></td>
        <td><p>Singleton </p></td>
        <td><p>Класс, который может иметь только один экземпляр.</p></td>
    </tr>
    <tr>
        <td width="630" colspan="3"><p><strong>Структурные
            шаблоны&nbsp;</strong><strong>(</strong><strong>Structural</strong><strong>)</strong>&nbsp;определяют
            различные сложные структуры, которые изменяют&nbsp;интерфейс&nbsp;уже существующих объектов или его
            реализацию, позволяя облегчить разработку и оптимизировать программу.</p></td>
    </tr>
    <tr>
        <td><p>Адаптер </p></td>
        <td><p>Adapter&nbsp;/ Wrapper</p></td>
        <td><p>Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой
            предоставляет несовместимый с первым интерфейс.</p></td>
    </tr>
    <tr>
        <td><p>Мост </p></td>
        <td><p>Bridge </p></td>
        <td><p>Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо.</p></td>
    </tr>
    <tr>
        <td><p>Компоновщик </p></td>
        <td><p>Composite </p></td>
        <td><p>Объект, который объединяет в себе объекты, подобные ему самому.</p></td>
    </tr>
    <tr>
        <td><p>Декоратор&nbsp;или Wrapper/Обёртка</p></td>
        <td><p>Decorator </p></td>
        <td><p>Класс, расширяющий функциональность другого класса без использования наследования.</p></td>
    </tr>
    <tr>
        <td><p>Фасад </p></td>
        <td><p>Facade </p></td>
        <td><p>Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.</p></td>
    </tr>
    <tr>
        <td><p>Единая точка входа</p></td>
        <td><p>Front Controller </p></td>
        <td><p>Обеспечивает унифицированный интерфейс для интерфейсов в подсистеме. Front Controller определяет
            высокоуровневый интерфейс, упрощающий использование подсистемы.</p></td>
    </tr>
    <tr>
        <td><p>Приспособленец </p></td>
        <td><p>Flyweight </p></td>
        <td><p>Это объект, представляющий себя как уникальный экземпляр в разных местах программы, но по факту не
            являющийся таковым.</p></td>
    </tr>
    <tr>
        <td><p>Заместитель </p></td>
        <td><p>Proxy </p></td>
        <td><p>Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает
            доступ к объекту, к которому обращаются через него.</p></td>
    </tr>
    <tr>
        <td width="630" colspan="3"><p><strong>Поведенческие
            шаблоны&nbsp;</strong><strong>(</strong><strong>Behavioral</strong><strong>)</strong>&nbsp;определяют
            взаимодействие между объектами, увеличивая таким образом его гибкость.</p></td>
    </tr>
    <tr>
        <td><p>Цепочка ответственности </p></td>
        <td><p>Chain of responsibility </p></td>
        <td><p>Предназначен для организации в системе уровней ответственности.</p></td>
    </tr>
    <tr>
        <td><p>Команда, Action, Transaction</p></td>
        <td><p>Command </p></td>
        <td><p>Представляет действие. Объект команды заключает в себе само действие и его параметры.</p></td>
    </tr>
    <tr>
        <td><p>Интерпретатор </p></td>
        <td><p>Interpreter </p></td>
        <td><p>Решает часто встречающуюся, но подверженную изменениям, задачу.</p></td>
    </tr>
    <tr>
        <td><p>Итератор,&nbsp;Cursor </p></td>
        <td><p>Iterator </p></td>
        <td><p>Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без
            использования описаний каждого из объектов, входящих в состав агрегации.</p></td>
    </tr>
    <tr>
        <td><p>Посредник </p></td>
        <td><p>Mediator </p></td>
        <td><p>Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты
            от необходимости явно ссылаться друг на друга.</p></td>
    </tr>
    <tr>
        <td><p>Хранитель,&nbsp;Token </p></td>
        <td><p>Memento </p></td>
        <td><p>Позволяет не нарушая инкапсуляцию зафиксировать и сохранить внутреннее состояния объекта так, чтобы
            позднее восстановить его в этом состоянии.</p></td>
    </tr>
    <tr>
        <td><p>Null Object </p></td>
        <td><p>Null object </p></td>
        <td><p>Предотвращает нулевые указатели, предоставляя объект «по умолчанию».</p></td>
    </tr>
    <tr>
        <td><p>Наблюдатель, Dependents, Publish-Subscribe,Listener </p></td>
        <td><p>Observer&nbsp;илиPublish/subscribe </p></td>
        <td><p>Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния
            одного объекта все зависящие от него оповещаются об этом событии.</p></td>
    </tr>
    <tr>
        <td><p>Слуга</p></td>
        <td><p>Servant </p></td>
        <td><p>Используется для обеспечения общей функциональности группе классов.</p></td>
    </tr>
    <tr>
        <td><p>Спецификация </p></td>
        <td><p>Specification </p></td>
        <td><p>Служит для связывания бизнес-логики.</p></td>
    </tr>
    <tr>
        <td><p>Состояние, Objects for States</p></td>
        <td><p>State </p></td>
        <td><p>Используется в тех случаях, когда во время выполнения программы объект должен менять свое поведение в
            зависимости от своего состояния.</p></td>
    </tr>
    <tr>
        <td><p>Стратегия </p></td>
        <td><p>Strategy </p></td>
        <td><p>Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их
            взаимозаменяемости.</p></td>
    </tr>
    <tr>
        <td><p>Шаблонный метод </p></td>
        <td><p>Template method </p></td>
        <td><p>Определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя
            его структуру в целом.</p></td>
    </tr>
    <tr>
        <td><p>Посетитель </p></td>
        <td><p>Visitor </p></td>
        <td><p>Описывает операцию, которая выполняется над объектами других классов. При изменении класса Visitor нет
            необходимости изменять обслуживаемые классы.</p></td>
    </tr>
    <tr>
        <td><p>Single-serving visitor</p></td>
        <td><p>Single-serving visitor </p></td>
        <td><p>Оптимизирует реализацию шаблона посетитель, который инициализируется, единожды используется, и затем
            удаляется.</p></td>
    </tr>
    <tr>
        <td><p>Hierarchical visitor</p></td>
        <td><p>Hierarchical visitor </p></td>
        <td><p>Предоставляет способ обхода всех вершин иерархической структуры данных (напр. древовидной).</p></td>
    </tr>
    </table>
    <p>&nbsp; </p>

    <p>&nbsp;</p>


</div>
</body>
</html>
